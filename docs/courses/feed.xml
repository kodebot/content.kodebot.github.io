<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>learning on kodebot</title>
    <link>http://localhost/kodebot/courses/</link>
    <description>Recent content in learning on kodebot</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Fri, 22 Feb 2019 10:25:49 +0000</lastBuildDate>
    
	<atom:link href="http://localhost/kodebot/courses/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Course overview</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-course-overview/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-course-overview/</guid>
      <description>Welcome to automated unit testing basics course.
This course is for anyone who has some knowledge of computer programming but have limited or no knowledge of automated unit testing.
This course is language, framework and tools agnostic. Everything you learn from this course can be applied to any programming language with the use of right tools.</description>
    </item>
    
    <item>
      <title>Result verification</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/4-verification-techniques/1-result-verification/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/4-verification-techniques/1-result-verification/</guid>
      <description>We use result verification technique when the test receives the result by running SUT.
Consider an example of testing a function that adds two numbers and returns the result
function add(a, b): return a+b  we verify the correctness of this function by simply checking the result returned by add function
function test_add(): // arrange a = 10 b = 15 // act result = add(a, b) // assert areEqual(25, result) // 25 is expected  </description>
    </item>
    
    <item>
      <title>Simple test data</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/1-simple-test-data/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/1-simple-test-data/</guid>
      <description>When we need data, we just create variables with the data and use them in the other places within the unit test.
consider an example of testing a function that adds two numbers
function add(a, b): return a+b  to test this function, we need two input data. We can simply create two variables with the data in our test function and use them as arguments for add() function.
function test_add(): // arrange a = 10 b = 15 // act add(a, b)  </description>
    </item>
    
    <item>
      <title>Structure</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/2-structure-of-unit-test/1-structure/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/2-structure-of-unit-test/1-structure/</guid>
      <description>Any unit test will have two or more of the following steps
 Setup Run SUT Verification Cleanup  Setup One of the first step in writing unit test is Setup. In this step, we prepare test data, dependencies and/or the context for the test.
For example, we will replace any real dependencies with fake ones and define set of good test data as part of this step.
However, this step is not necessary for all the tests.</description>
    </item>
    
    <item>
      <title>Test driven development</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/5-test-driven-or-test-oriented/1-test-driven-development/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/5-test-driven-or-test-oriented/1-test-driven-development/</guid>
      <description>Test driven development (TDD) is a popular approach for writing unit tests.
With this approach, we write a test first, see it fail, then write production code to make the test pass.
Typically, we repeat the steps below in that order 1. take a small requirement 2. write failing test for the requirement 3. write production code to make test pass 4. refactor
It is claimed that TDD helps to write code that simple, flexible and just enough to satisfy the requirement.</description>
    </item>
    
    <item>
      <title>What is automated unit testing?</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/1-what-is-automated-unit-testing/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/1-what-is-automated-unit-testing/</guid>
      <description>Let&amp;rsquo;s first understand what we call as Unit. The term unit is very subjective, so it means different things to different people. In the context of testing, I like to think of unit as one or more lines of code that does something small but tangible to move towards achieving the end goal of the program.
What do I mean by this? Well, lets look at an example of a very simple calculator program.</description>
    </item>
    
    <item>
      <title>Data driven test</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/2-data-driven-test/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/2-data-driven-test/</guid>
      <description>When we want to test SUT, we usually want to test with different set of data. It is not ideal to create one test function for one set of input data. This is where data driven tests are helpful.
Consider the same example function that adds two numbers
function add(a, b): return a+b  To be thorough, we need to test this function with few different set of data including but not limited to negative numbers, positive numbers and zeros.</description>
    </item>
    
    <item>
      <title>State verification</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/4-verification-techniques/2-state-verification/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/4-verification-techniques/2-state-verification/</guid>
      <description>State verification is similar to result verification but rather than checking the result of SUT, we check the state of an object or something similar.
Consider an example of testing a function that closes the database connection
module databaseManager isOpen function close(): isOpen = false  When we call this function, it is not going to return anything, instead it is going to change the state of isOpen field
So we need to verify the state of isOpen field to ensure the correctness of close function</description>
    </item>
    
    <item>
      <title>Test oriented development</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/5-test-driven-or-test-oriented/2-test-oriented-development/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/5-test-driven-or-test-oriented/2-test-oriented-development/</guid>
      <description>Test oriented development is another approach where it is not important to write tests first but it is important to write test while writing production code.
Typically, we repeat the steps below in that order 1. take a small requirement 2. write production code 3. write unit tests 4. refactor</description>
    </item>
    
    <item>
      <title>Why are we writing unit tests?</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/2-why-are-we-writing-unit-tests/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/2-why-are-we-writing-unit-tests/</guid>
      <description>We can find many reasons for writing unit tests, there are three reasons that stands out in my opinion
 Verify the correctness of the code Provide safety-net when we want to change the code (feedback mechanism) Serve as a documentation of the code  Verify the correctness of the code I don&amp;rsquo;t think any good developer will just write code and say the work is done. They will test it, either via manual steps or by writing automated unit tests, to verify whether the implementation is correct or not.</description>
    </item>
    
    <item>
      <title>Fake test dependency</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/3-fake-test-dependency/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/3-fake-test-dependency/</guid>
      <description>It is very common that the SUT depends on something else. The dependency could be anything like another function, object or external system and we may not be able to control their behavior all the time. A good unit test should not be affected by the changes in the dependencies of SUT.
So, a common technique is to replace the dependencies with fake versions that we can control.
For example, consider a function that takes age of the passenger and prints whether he/she is eligible for senior citizen discount when promotion is available.</description>
    </item>
    
    <item>
      <title>Interaction verification</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/4-verification-techniques/3-interaction-verification/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/4-verification-techniques/3-interaction-verification/</guid>
      <description>Interaction verification is completely different from result and state verification. With this technique, we will be checking whether an interaction under a specific condition has happened or not.
Consider the example below, the databaseManager module offers a function to close database, but it neither returns any result nor changes the state. All this function does is that it calls a function in database module.
module databaseManager function close(): database.close()  So, the only thing we can do to verify the correctness of this function is to check whether it calls close() function in database module or not</description>
    </item>
    
    <item>
      <title>What is good unit test?</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/3-what-is-good-unit-test/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/3-what-is-good-unit-test/</guid>
      <description>When writing tests for any block of code, it must be comprehensive and cover all the scenarios. If we write tests for most obvious scenarios and don&amp;rsquo;t cover the less common scenarios then we don&amp;rsquo;t know how it is going to behave on those untested scenarios.
Each test we write should have the following qualities
 Quick to run Repeatable Focused Isolated Self validating  Quick to run When running unit test, we don&amp;rsquo;t want to wait long.</description>
    </item>
    
    <item>
      <title>Mock dependency</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/4-mock-dependency/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/3-setup-techniques/4-mock-dependency/</guid>
      <description>While fake dependencies are really useful for unit testing, they lack in features like tracking function calls, intercepting arguments, etc.. that makes unit testing easier. Mock dependency is a dependency which offers all the benefits of fake dependencies and more features to make unit testing easier.
It is not going to be easy to create and maintain mock dependencies; this is why we generally use mocking libraries to create mock dependencies.</description>
    </item>
    
    <item>
      <title>Other types of automated testing</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/4-other-types-of-automated-testing/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/4-other-types-of-automated-testing/</guid>
      <description>While unit test targets small piece of code, we have other types of test that generally focus at higher level than unit tests. Two examples of such types of test we have are
 Integration tests End to end tests  Generally, unit tests focus on small piece of code without considering the behavior of dependencies they have (usually with the help of fake dependencies). This means we will be able to verify whether the target code works on it own or not, but we will not know whether it is going to work correctly as a part of bigger program.</description>
    </item>
    
    <item>
      <title>System Under Test (SUT)</title>
      <link>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/5-system-under-test/</link>
      <pubDate>Fri, 22 Feb 2019 10:25:49 +0000</pubDate>
      
      <guid>http://localhost/kodebot/courses/courses/automated-unit-testing-basics/1-introduction/5-system-under-test/</guid>
      <description>The implementation of System Under Test (SUT) that are the target of our unit test can be one of the following
 direct implementation indirect implementation combination of the above  Direct implementation If a function or piece of code is direct implementation, then it will take zero or more inputs and provide some results or cause state change with very little or no dependencies.
Examples of direct implementation</description>
    </item>
    
  </channel>
</rss>