[
{
	"uri": "https://kodebot.com/blog/",
	"title": "Blog",
	"tags": [],
	"description": "",
	"content": "Posts \rJoin and GroupJoin in C#\r\r\rtmux One Minute Guide\r\r\rNodeJs: Loops, Closure and Async Invocation\r\r\rException Handling in NodeJS\r\r\rUnit Testing Entity Framework async Queries\r\r\rUnit Testing Entity Framework Queries\r\r\rVS-TAC - Cordova version\r\r\rASP.NET MVC 5 - JsonResult with Http Status Code 400\r\r\rAngularJS 1.x - Validation on File Input type\r\r\rAngular 1.x - Unit Testing a function that returns Promise\r\r\rTypeScript - Accessing object with null key\r\r\rASP.NET MVC 5 Hosting for Integration / E2E Testing\r\r\rHow to isolate AutoMapper in Unit Tests?\r\r\rASP.NET 5 - Tag Helpers, the HTML way\r\r\rASP.NET 5 - Environment specific pipeline configuration\r\r\rOwin - Katana core middleware patterns\r\r\rTypeScript - \u0026#39;this\u0026#39; reference in AngularJS event handler\r\r\rTypeScript build automation in ASP.NET 5 (MVC6) using Gulp\r\r\rMVC 6 Camel Case JSON\r\r\rTPL Task and Windows Identity Impersonation - The beauty of Closure\r\r\rSelenium and Page Objects\r\r\rECMAScript 6 - Sublime Text editor build system\r\r\rSix stars of AngularJS - Part 3\r\r\rSix stars of AngularJS - Part 2\r\r\rSix stars of AngularJS - Part 1\r\r\rNSequenceComparer to compare two sequences\r\r\rMocking function that returns promise\r\r\rStrucuring unit tests\r\r\rDecorator over Inheritance hierarchy\r\r\rOrganize AngularJS Tests within a test file\r\r\rSetup Chutzpah to Run Javascript Tests in VisualStudio\r\r\r"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/",
	"title": "Automated unit testing basics",
	"tags": [],
	"description": "",
	"content": "Welcome to automated unit testing basics tutorial.\nThis tutorial is for anyone who has some knowledge of computer programming but have limited or no knowledge of automated unit testing.\nThis tutorial is language, framework and tools agnostic. Everything you learn from this tutorial can be applied to any programming language with the use of right tools.\nThis tutorial is also available as a video to watch if you prefer that   "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Introduction In this chapter, we will see what is automated unit testing, why we need them, what are the qualities of good unit tests and what are the other types of tests we have.\nFinally, we will take a brief look at different implementation types of the code that we need to be aware of when writing unit tests.\n \rWatch video\r\r "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/4-verification-techniques/1-result-verification/",
	"title": "Result verification",
	"tags": [],
	"description": "",
	"content": "We use result verification technique when the test receives the result by running SUT.\nConsider an example of testing a function that adds two numbers and returns the result\nfunction add(a, b):\rreturn a+b\rwe verify the correctness of this function by simply checking the result returned by add function\nfunction test_add():\r// arrange\ra = 10\rb = 15\r// act\rresult = add(a, b)\r// assert\rareEqual(25, result) // 25 is expected\r"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/3-setup-techniques/1-simple-test-data/",
	"title": "Simple test data",
	"tags": [],
	"description": "",
	"content": "When we need data, we just create variables with the data and use them in the other places within the unit test.\nconsider an example of testing a function that adds two numbers\nfunction add(a, b):\rreturn a+b\rto test this function, we need two input data. We can simply create two variables with the data in our test function and use them as arguments for add() function.\nfunction test_add():\r// arrange\ra = 10\rb = 15\r// act\radd(a, b)\r"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/2-structure-of-unit-test/1-structure/",
	"title": "Structure",
	"tags": [],
	"description": "",
	"content": "Any unit test will have two or more of the following steps\n Setup Run SUT Verification Cleanup  Setup One of the first step in writing unit test is Setup. In this step, we prepare test data, dependencies and/or the context for the test.\nFor example, we will replace any real dependencies with fake ones and define set of good test data as part of this step.\nHowever, this step is not necessary for all the tests.\nThis step is commonly referred to as Arrange or Fixture setup\nRun SUT This is the step that runs the SUT with test data and/or fake dependencies. This is a mandatory step for any unit test.\nThis step is commonly referred to as Act or Exercise sut\nVerification This step verifies the result of running SUT under test condition. This is a mandatory step.\nThis step is commonly referred to as Assert or Verify Outcome\nCleanup This is optional step and needed only when any clean up is required after the test run. This step is commonly referred to as Fixture teardown\nAAA One of the popular acronym for testing steps or phases is AAA, and it refers to Arrange, Act and Assert. Because cleanup is not a common step, it is omitted.\nHere is an example of AAA pattern test:\nfunction test_add():\r// arrange\ra = 10\rb = 15\r// act\rresult = add(a, b)\r// assert\rareEqual(25, result) // 25 is expected\r"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/5-test-driven-or-test-oriented/1-test-driven-development/",
	"title": "Test driven development",
	"tags": [],
	"description": "",
	"content": "Test driven development (TDD) is a popular approach for writing unit tests.\nWith this approach, we write a test first, see it fail, then write production code to make the test pass.\nTypically, we repeat the steps below in that order\n take a small requirement write failing test for the requirement write production code to make test pass refactor  It is claimed that TDD helps to write code that simple, flexible and just enough to satisfy the requirement.\n"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/1-introduction/1-what-is-automated-unit-testing/",
	"title": "What is automated unit testing?",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s first understand what we call as Unit. The term unit is very subjective, so it means different things to different people. In the context of testing, I like to think of unit as one or more lines of code that does something small but tangible to move towards achieving the end goal of the program.\nWhat do I mean by this? Well, lets look at an example of a very simple calculator program. In order to build a calculator, we need to build individual operations that are supported by the calculator. Each simple operations like addition, subtraction, multiplication and division are implemented using few lines of code and these operations are units as these are small but tangible steps needed to build a calculator.\nHowever, we cannot say all the operations supported by a calculator are made up of single unit. There are some operations like average, percentage, etc are not simple ones and they are implemented using group of units. For example, average is implemented using addition and division.\nUnit is loosely defined term and subjective. In most cases you can refer a small function/subroutine as unit but it is not always true. There may be functions/subroutines that are made up of group of units.\n\rSo, Unit testing is taking a small piece of code that is written to do something small but tangible and test it to verify whether it is working as expected or not.\nAutomated unit testing means, the unit testing process is automated by writing code, so the tests are written once and run as many times as we like without any manual overhead.\nFor example, the tests you need for the individual units of a calculator program are called unit tests. If those tests are automated with code then you can refer to them as automated unit tests.\nI will be referring to the unit of code we are testing as System Under Test or SUT and automated unit test as simply unit test going forward.\n\r"
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/",
	"title": "SOLID Principles",
	"tags": [],
	"description": "",
	"content": "Welcome to this tutorial on SOLID principles.\nThis tutorial is for anyone who has some knowledge of any object oriented programming language and want to develop or improve the skills of designing flexible and maintainable software.\nThe examples in the tutorial use C#, but anyone with some experience on any object oriented programming language can follow along easily.\nThis tutorial is also available as a video to watch if you prefer that   "
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/1-introduction/",
	"title": "What is SOLID principles?",
	"tags": [],
	"description": "",
	"content": " \rWatch video\r\r SOLID is mnemonic acronym where each letter represents one principle.\nThe principles were first introduced by Robert C. Martin but the acronym was later introduced by Michael Feathers.\nThe following are the principles that makes up SOLID\n Single Responsibility Principle Open-Closed Principle Liskov Substitution Principle Interface Segregation Principle Dependency Inversion Principle  When designing software using object oriented methodology, the SOLID principles help to keep the design readable, flexible and maintainable.\nIn the upcoming chapters, we cover each of these principles in detail with example code that violates the principle and refactored code that confirms to the principle.\n"
},
{
	"uri": "https://kodebot.com/",
	"title": "Kodebot",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/3-setup-techniques/2-data-driven-test/",
	"title": "Data driven test",
	"tags": [],
	"description": "",
	"content": "When we want to test SUT, we usually want to test with different set of data. It is not ideal to create one test function for one set of input data. This is where data driven tests are helpful.\nConsider the same example function that adds two numbers\nfunction add(a, b):\rreturn a+b\rTo be thorough, we need to test this function with few different set of data including but not limited to negative numbers, positive numbers and zeros.\nAlthough, it will be descriptive and easy to follow when we have one test test function per input data, it requires more development and maintenance effort.\nBetter solution is to create one test function that we can run with different set of data. This is what we call data driven tests.\nAn example of data driven test would look like this\ntype DataTest:\rinput1\rinput2\rresult\rfunction test_add():\r// arrange\rtests = [\r[input1: 1, input2: 2, result: 3],\r[input1: -1, input2: -1, result: 0],\r[input1: 1, input2: -2, result: -1],\r]\r// act\rloop test of tests:\rresult = add(test.input1, test.input2)\r// assert\rareEqual(test.result, result)\rThe actual implementation of data driven test will be different based on the language and the framework used.\n"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/4-verification-techniques/2-state-verification/",
	"title": "State verification",
	"tags": [],
	"description": "",
	"content": "State verification is similar to result verification but rather than checking the result of SUT, we check the state of an object or something similar.\nConsider an example of testing a function that closes the database connection\nmodule databaseManager\risOpen\rfunction close():\risOpen = false\rWhen we call this function, it is not going to return anything, instead it is going to change the state of isOpen field\nSo we need to verify the state of isOpen field to ensure the correctness of close function\nfunction test_close():\r// arrange\rdatabaseManager.isOpen = true\r// act\rdatabaseManager.close()\r// assert\rareEqual(false, databaseManager.isOpen) // false is expected\r"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/2-structure-of-unit-test/",
	"title": "Structure of unit test",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Structure of unit test In this chapter, let\u0026rsquo;s look at the structure of the unit test.\n \rWatch video\r\r "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/5-test-driven-or-test-oriented/2-test-oriented-development/",
	"title": "Test oriented development",
	"tags": [],
	"description": "",
	"content": "Test oriented development is another approach where it is not important to write tests first but it is important to write test while writing production code.\nTypically, we repeat the steps below in that order\n take a small requirement write production code write unit tests refactor  "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/1-introduction/2-why-are-we-writing-unit-tests/",
	"title": "Why are we writing unit tests?",
	"tags": [],
	"description": "",
	"content": "We can find many reasons for writing unit tests, there are three reasons that stands out in my opinion\n Verify the correctness of the code Provide safety-net when we want to change the code (feedback mechanism) Serve as a documentation of the code  Verify the correctness of the code I don\u0026rsquo;t think any good developer will just write code and say the work is done. They will test it, either via manual steps or by writing automated unit tests, to verify whether the implementation is correct or not.\nSafety-net or feedback mechanism for changes Once the code is written, we may change it for various reason - ranging from changing business requirements to simply to fix a bug in the code. When we want to change code, we need to be very careful to make sure we are not introducing any bugs or unintended side effects. The term used to refer to the bugs or unintended side effects caused by code change is regression. Generally, the bigger the program gets the challenging it becomes to keep regression issues under control. This is where unit tests are really useful. If we have good, solid unit tests covering the current code then we will be able to get immediate feedback on any change the causes regression issues.\nDocumentation of the code By providing suitable name/description for the tests and keeping it covering all scenarios of the SUT, the tests can be used as a documentation or specification by developers.\n"
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/2-single-responsibility-principle/",
	"title": "Single Responsibility Principle",
	"tags": [],
	"description": "",
	"content": " \rWatch video\r\r Single Responsibility Principle (SRP) is about how we separate or modularise code in object oriented design. This principle says that\n A class should have only one reason to change\n If we naively apply this principle, we will end up with several classes where each class contains just one method and that just does one small thing. This leads to unnecessary complexity. This is clearly not what we want to achieve with this principle.\nRobert C. Martin who introduced this principle clarified that this principle is \u0026ldquo;about people\u0026rdquo;. Any changes to a class should originate from a single person or a group of people representing a department or business division or similar within the company/organisation that uses the application.\nIf changes to a class is originating from more than one person/department/division then the class is said to have multiple responsibilities and it violates single responsibility principle.\nFor example, say we have a class Student that calculates grade for students and also tracks the books they borrowed from library.\npublic class Student { public string CalculateGrade() { // calculate and return grade  } public void BorrowBook(int bookId) { // record the book borrowed  } public void ReturnBook(int bookId) { // record that the book is returned  } } Any changes to this class can be requested by one of two departments\n teaching department may ask to change the way we calculate grading library department may ask for changes to the way we record borrowed and returned books  So, two different departments are responsible for this class. In other words, this class fulfils different requirements of two different departments.\nIn the context of this principle, we can think of responsibility as \u0026ldquo;reason to change\u0026rdquo;. What we perceive as responsibility or reason to change may be different based on the domain and the problem we are solving.\n\rIf you are wondering why having a class that changes for more than one reason is not a good idea, then say library department asks for some changes to the way books are borrowed. While making the changes for library department, there is very high risk of breaking CalculateGrade() method.\nThis is because we don\u0026rsquo;t know how the code is intertwined within the class.\nEven if we are very careful and made sure the functionality of the CalculateGrade() method is unaffected, at the very least we need to ask teaching department to test grade calculation and this is not ideal.\nSo, separating unrelated methods into different classes is a good idea, but at the same time, we need to make sure we don\u0026rsquo;t end up with atomised classes.\nAtomised class refers to a class that is unnecessarily designed to have very few methods (usually just one method) which achieves very small thing.\n\rRobert C. Martin provided the following complementing definition to clear some of the misinterpretation of this principle\n Gather together the things that change for the same reasons and separate those things that change for different reason\n This complementing definition sort of says that we need to increase cohesion and decrease coupling of classes. This will help us to avoid atomised classes.\nIn the context of a class, cohesion means the methods and properties must be closely related and coupling means the level of interdependencies between classes.\n\rWith all these in mind, we can refactor the Student class as follow\npublic class StudentGrade { public string CalculateGrade() { // calculate and return grade  } } public class StudentLibraryTracker { public void BorrowBook(int bookId) { // record the book borrowed  } public void ReturnBook(int bookId) { // record that the book is returned  } } Now, StudentGrade class only fulfils the requirements of teaching department so it will only change for the requests from teaching department.\nStudentLibraryTracker class only fulfils the requirements of library department and any changes needed will only originate from library department.\nNote here, we have not split the original class into three different class each with one method. We have StudentLibraryTracker class with two methods and StudentGrade class with one method.\nThis is because we have taken the complementary principle into account and gathered BorrowBook() and ReturnBook() into one class because they change for the same reason and separated CalculateGrade() to different class because it is not changing for the same reason as the other two methods.\nReferences   https://en.wikipedia.org/wiki/Single_responsibility_principle\n  https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\n  https://hackernoon.com/you-dont-understand-the-single-responsibility-principle-abfdd005b137\n  http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod\n  "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/3-setup-techniques/3-fake-test-depencency/",
	"title": "Fake test dependency",
	"tags": [],
	"description": "",
	"content": "It is very common that the SUT depends on something else. The dependency could be anything like another function, object or external system and we may not be able to control their behavior all the time. A good unit test should not be affected by the changes in the dependencies of SUT.\nSo, a common technique is to replace the dependencies with fake versions that we can control.\nFor example, consider a function that takes age of the passenger and prints whether he/she is eligible for senior citizen discount when promotion is available.\nThe function which tells whether the promotion is available or not is defined in another module and we don\u0026rsquo;t have control over its behavior\nmodule promotions\rfunction isPromotionsAvailable():\r.\r.\r.\rmodule discounts\rfunction isDiscountAvailable(age):\rif promotions.isPromotionAvailable() \u0026amp;\u0026amp; age \u0026gt; 60:\rprint(\u0026quot;discount available\u0026quot;)\relse:\rprint(\u0026quot;discount not available\u0026quot;)\rHowever, in order to test all the branches and conditions of isDiscountAvailable() function, we need to be able to control the result of isPromotionAvailable() function. So, we first create fake version of isPromotionAvailable() function in fakePromotions module with an option for us to control the result\nmodule fakePromotions\rofferPromotion = true\rfunction isPromotionAvailable():\rreturn offerPromotion\rthen replace the promotion with fakePromotion inside the test\nfunction test_isDiscountAvailable():\r// arrange\rpromotions = fakePromotions //replace promotions module with fakePromotions module\rpromotions.offerPromotion = true\rage = 65\r// act\rresult = discounts.isDiscountAvailable(age)\rDepending on the language and framework we use, the way we replace the real dependency with fake one will be different.\n"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/4-verification-techniques/3-interaction-verification/",
	"title": "Interaction verification",
	"tags": [],
	"description": "",
	"content": "Interaction verification is completely different from result and state verification. With this technique, we will be checking whether an interaction under a specific condition has happened or not.\nConsider the example below, the databaseManager module offers a function to close database, but it neither returns any result nor changes the state. All this function does is that it calls a function in database module.\nmodule databaseManager\rfunction close():\rdatabase.close()\rSo, the only thing we can do to verify the correctness of this function is to check whether it calls close() function in database module or not\nfunction test_close():\r// arrange\rmockDatabase = mock(database)\rdatabase = mockDatabase\r// act\rdatabaseManager.close()\r// assert\rmockDatabase.close().calledOnce() "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/3-setup-techniques/",
	"title": "Setup techniques",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Setup techniques Let\u0026rsquo;s look at some of the basic techniques we use at the setup stage of our unit test\nWe are going to look at the following techniques\n simple test data data driven test Fake test dependency or test double Mock dependency   \rWatch video\r\r "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/1-introduction/3-what-is-good-unit-test/",
	"title": "What is good unit test?",
	"tags": [],
	"description": "",
	"content": "When writing tests for any block of code, it must be comprehensive and cover all the scenarios. If we write tests for most obvious scenarios and don\u0026rsquo;t cover the less common scenarios then we don\u0026rsquo;t know how it is going to behave on those untested scenarios.\nEach test we write should have the following qualities\n Quick to run Repeatable Focused Isolated Self validating  Quick to run When running unit test, we don\u0026rsquo;t want to wait long. Because each of the tests we write target only few lines of the code, we could easily end up with hundreds, if not thousands, of tests even for a small program/application. Our tests must be extremely fast to get the feedback quickly. So we should try to avoid anything that will slow down our tests. When this is not possible, we should at least be able to keep the slow running tests separate and run them independently without affecting fast running tests.\nRepeatable We should be able to run our tests repeatedly without any manual interventions. This means anything that our test needs should be done in the test itself.\nFor example, if we need our application to be in a particular state for running a test, then the test itself should bring the application to the desired state as a prerequisite, perform the steps necessary for the test and do any necessary cleanups at the end of the test.\nFocused We don\u0026rsquo;t want one test trying to verify too many things. Each test should verify just one thing.\nFor example, if we have a function to validate bank account number then we should try to create one test for each validation rule. That is, one test for each of the rules listed below\n verify account number is not null or empty verify account number is exactly 8 characters verify account number is only contains digits  Isolated Any test should not depend on any other test(s). Although it is very common for a function or object to depend on other functions or objects, the test we write targeting a particular block of code should not be affected if the behavior of any of its dependent function or object changes.\nSelf validating Each test we write should give us the feedback at the end on its own. We should not rely on anything other than the test itself for the result.\n"
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/3-open-closed-principle/",
	"title": "Open-Closed Principle",
	"tags": [],
	"description": "",
	"content": " \rWatch video\r\r Open-Closed Principle(OCP) says software must be open for extension but closed for modification. When we first hear this, it might sound like oxymoron but it is not when we understand this principle correctly.\nThis principle was first introduced by Bertrand Meyer and his definition of this principle is:\n Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.\n Later, Robert C. Martin provided the following improved definition which is suitable for modern software development\n You should be able to extend the behaviour of a system without having to modify that system.\n Let\u0026rsquo;s try to understand this in detail. How can a software be open for extension and closed for modification? After all, if we want to add a new functionality or change an existing functionality, we need to change the code. So what this principle is actually talking about then?\nThe principle says\n identify changes that are frequent keep the parts of system affected by those frequent changes open for extension keep the parts of system not affected by those changes closed for modification  Let\u0026rsquo;s look at an example to make this clear.\nWe have an Accountant class here that calculates tax for given income\npublic class Accountant { public decimal CalculateTax(decimal income){ return income * 0.2m; } } We can say, the code in the example above confirms to Open-Closed principle as long as the CalculateTax() method doesn\u0026rsquo;t need to be changed frequently. It doesn\u0026rsquo;t need to be changed when the Accountant class supports only one country and the tax rules or laws for that country is not changed frequently.\nOn the other hand, if we want to support tax calculation for other countries then we can \u0026ldquo;modify\u0026rdquo; CalculateTax() method, like in the example below, to have different calculation per country\npublic class Accountant { private readonly Country _country; public Accountant(Country country) { _country = country; } public decimal CalculateTax(decimal income) { switch(_country) { case Country.UK: return income * 0.2m; case Country.USA: return income * 0.25m } } } Every time we add support for new country, the CalculateTax() method need to be updated.\nNote, in this example, we have introduced a new constructor parameter of type Country enum. This represents a country that need to be used when calculating tax. The CalculateTax() method is modified to use different tax calculation based on the country that was passed in when Accountant class was constructed.\nIf we know that we are going to add support for more countries frequently, then Accountant class is definitely not confirming to Open-Closed Principle.\nTo confirm to Open-Closed Principle, we need to make the code in CalculateTax() method open for extension but keep the Accountant class and its contract closed for modification.\nWe need to keep Accountant class and its contract closed because, we don\u0026rsquo;t want the consumers of Accountant class affected whenever a new country is added. That is, if the contract (i.e. public signature) of Accountant class is changed then we need to update all the existing consumers or if the CalculateTax() method body is changed then we have high risk of breaking existing functionality and some or all of the existing consumers may be affected.\nNeither of those scenarios are ideal.\nOne of the ways of making Accountant class confirming to Open-Closed Principle is by using abstraction. We can abstract the tax calculation by creating an interface. The interface will have just one method in this case and that will take the income as input and return tax as a result.\npublic interface ITaxCalculator { decimal Calculate(decimal income); } Now we need to change the constructor of Accountant class to accept ITaxCalculator instead of Country enum as parameter.\nThe new version of Accountant class that confirms to Open-Closed Principle will look like the following\npublic class Accountant { private readonly ITaxCalculator _taxCalculator; public TaxCalculator(ITaxCalculator taxCalculator) { _taxCalculator = taxCalculator; } public decimal CalculateTax(decimal income) { return _taxCalculator.Calculate(income); } } We can create concrete versions of this interface for each country implementing tax calculation applicable for each of those countries without changing Accountant class.\nAnother example for Open-Closed Principle is \u0026ldquo;plugin\u0026rdquo; model implementation. Plugins allow extending the functionality of host program with out changing its code.\nWhen confirming to Open-Closed Principle, more often than not, we might need to make some modification but, those modification are usually isolated and trivial. For example, when creating a new class supporting tax calculation for a new country, the Country enum need to be updated to include the new country and any logic that we have to map Country enum value to tax calculation class need to be updated to include the new ones.\nIf we look at the essence of the example we have seen so far, it is all about swapping the tax calculation logic at runtime. We don\u0026rsquo;t necessarily need to use interface to achieve this. We can use higher order function (i.e. function taking another function as a parameter), abstract class or anything that allows swapping code at runtime to get the same end result.\nDesigning a software that confirms to Open-Closed Principle for every possible change that may occur in the future is impossible and trying to do that will only create unnecessary complexity and increase the cost of initial development.\nRobert C. Martin says\n Resisting premature abstraction is as important as abstraction itself\n So, we need to identify what to design that confirms to Open-Closed Principle and what not to. Sometimes we can identify this by making an educated guess based on our experience or by talking to domain experts but sometimes we need to wait until the first change occurs.\nSometimes, we may get it wrong and design something that rarely changes but confirms to Open-Closed Principle. so, as you guessed, the challenge is not in applying Open-Closed Principle but identifying what should be designed confirming this principle.\nReferences   https://hackernoon.com/why-the-open-closed-principle-is-the-one-you-need-to-know-but-dont-176f7e4416d\n  https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html\n  Chapter 9 - Agile Principles, Patterns, and Practices in C# by Robert C. Martin and Micah Martin\n  "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/3-setup-techniques/4-mock-dependency/",
	"title": "Mock dependency",
	"tags": [],
	"description": "",
	"content": "While fake dependencies are really useful for unit testing, they lack in features like tracking function calls, intercepting arguments, etc.. that makes unit testing easier. Mock dependency is a dependency which offers all the benefits of fake dependencies and more features to make unit testing easier.\nIt is not going to be easy to create and maintain mock dependencies; this is why we generally use mocking libraries to create mock dependencies.\nIf we take the same passenger discount example that we have seen previously\nmodule promotions\rfunction isPromotionsAvailable():\r.\r.\r.\rmodule discounts\rfunction isDiscountAvailable(age):\rif promotions.isPromotionAvailable() \u0026amp;\u0026amp; age \u0026gt; 60:\rprint(\u0026quot;discount available\u0026quot;)\relse:\rprint(\u0026quot;discount not available\u0026quot;)\rwe create, setup and use mock version of isPromotionAvailable() like this in the tests:\nfunction test_isDiscountAvailable():\r// arrange\rmockPromotions = mock(promotions) // create mock promotion\rmockPromotions.isPromotionAvailable().return(true) // setup the method to return true\rpromotions = mockPromotions // replace promotions with mockPromotions\rage = 65\r// act\rresult = discounts.isDiscountAvailable(age)\rDepending on the language and framework we use, the way we create, setup and use mock dependencies will be different.\n"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/1-introduction/4-other-types-of-automated-testing/",
	"title": "Other types of automated testing",
	"tags": [],
	"description": "",
	"content": "While unit test targets small piece of code, we have other types of test that generally focus at higher level than unit tests. Two examples of such types of test we have are\n Integration tests End to end tests  Generally, unit tests focus on small piece of code without considering the behavior of dependencies they have (usually with the help of fake dependencies). This means we will be able to verify whether the target code works on it own or not, but we will not know whether it is going to work correctly as a part of bigger program. While this is the correct approach for unit tests, it doesn\u0026rsquo;t cover verifying the behavior with real dependencies. Integration and End to end tests falls under this category where SUT will be tested with real dependencies.\nIntegration tests aim testing SUT with one or more real dependencies and may use some fake dependencies if required. On the other hand End to end test try to test the application just like how end user will use it. End to end tests generally use publicly accessible parts like UI or API for testing. While it is not common, end to end tests can use fake dependencies if required but it should be kept to minimum.\nWhen writing tests for any application, we should use Integration and End to end tests along with Unit tests.\nPeople use the following pyramid diagram to show the distribution of these three types of tests that we should have for any program/application.\nAs we can see, Unit tests should be the majority. We should use Integration and End to end tests as and when they are required but they are small in number compared to Unit tests.\n"
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/4-verification-techniques/",
	"title": "Verification techniques",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Verification techniques One of the very important step in unit test is verification. We verify whether the SUT works as expected or not with the test data.\nWe generally use one of the following three verification techniques depending on the situation\n result verification state verification interaction verification   \rWatch video\r\r "
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/4-liskov-substitution-principle/",
	"title": "Liskov Substitution Principle",
	"tags": [],
	"description": "",
	"content": " \rWatch video\r\r Liskov Substitution Principle(LSP) is about substitution of one object for another without affecting the program that uses those objects.\nBarbara Liskov introduced this principle and she says\n What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behaviour of P is unchanged when o1 is substituted for o2 then S is a subtype of T.\n Let\u0026rsquo;s understand this with an example.\nSuppose we have a class MusicPlayer which allows users to play music\npublic class MusicPlayer { public virtual void Play() { // play song  } } We have TrialMusicPlayer which is inherited from MusicPlayer class\npublic class TrialMusicPlayer : MusicPlayer { public override void Play() { if(_songsPlayedToday \u0026gt;= 5) { throw new Exception(\u0026#34;Only 5 songs are allowed in a day.\u0026#34;); } // play song  } } TrialMusicPlayer class overrides Play() method to allow playing only 5 songs a day.\nWe have another class PlayerWidget.\npublic class PlayerWidget { private readonly MusicPlayer _player; public PlayerWidget(MusicPlayer player) { _player = player; } public void PlayButtonPressed() { _player.Play(); } } This class represents one of the user interfaces that user can use to control the music player and it simply delegates user requests to the MusicPlayer.\nThe essence of Liskov Substitution Principle is that we should be able to use objects of derived type in place of objects of base type without altering the behaviour of the program that is using those objects, only then we can call the derived type as subtype.\nIn this example, TrialMusicPlayer is not qualified to be subtype of MusicPlayer because, we cannot substitute the object of TrialMusicPlayer for the object of MusicPlayer without changing (or breaking) PlayerWidget. This is because PlayerWidget is not built to handle the new exception thrown by TrialMusicPlayer when more than 5 songs are played.\nThere are many subtle ways in which we can break substitutability of objects.\nThe following are the general rules to follow to avoid breaking substitutability\nNo new exception No new exception from any method in the subtype. However, we can throw new exception which is subtype of the exception thrown by base class. This is because the exception handler of a type will handle the exceptions of derived exception type as well.\nCovariance of return type and Contravariance of arguments in subtype methods Let\u0026rsquo;s first understand what covariance and contravariance mean.\nCovariance and Contravariance come into picture when we are dealing with complex type with one or more independent type components in them. Generics is one such type so we use custom generic type ISpecialList\u0026lt;T\u0026gt; for our example.\nLet\u0026rsquo;s say we have a base class Person. We have another class Employee which is derived from Person.\nIn general, if can assign object of Employee to type Person, but assigning object of Person to type Employee is not allowed.\nPerson p = new Employee(); // OK  Employee e = new Person(); // Compile time error This is not true by default for generic types like ISpecialList\u0026lt;T\u0026gt;. We cannot assign object of ISpecialList\u0026lt;Employee\u0026gt; to type ISpecialList\u0026lt;Person\u0026gt; or vice versa.\nHowever, we can allow these assignments to work using variance.\nIf we allow assigning the object of ISpecialList\u0026lt;Employee\u0026gt; to type ISpecialList\u0026lt;Person\u0026gt; then we say ISpecialList\u0026lt;T\u0026gt; is covariant\nIf we allow assigning the object of ISpecialList\u0026lt;Person\u0026gt; to type ISpecialList\u0026lt;Employee\u0026gt; then we say ISpecialList\u0026lt;T\u0026gt; is contravariant\nIn order to avoid breaking substitutability, the method arguments must be contravariant and return type must be covariant in subtype.\nIn C#, you can create covariant interface using out keyword and contravariant interface using in keyword. For example, ISpecialList\u0026lt;out T\u0026gt; is covariant and ISpecialList\u0026lt;in T\u0026gt; is contravariant.\n\rNo strengthening of Preconditions Preconditions are any validation that we perform before executing a method and it should not be strengthened in a subtype\nNo weakening Postconditions Postconditions are any validation that we perform after the method is executed and it should not be weakened in a subtype\nPreserve Invariants Invariant refers to properties or states that are preserved when the method is executed. Any such invariants of supertype must be preserved in a subtype\nHistory constraint Subtype should not introduce a new method that allows mutating state that is immutable in supertype\nReferences   https://en.wikipedia.org/wiki/Liskov_substitution_principle\n  https://www.hpl.hp.com/techreports/90/HPL-90-121.pdf\n  Covariance and Contravariance - Wikipedia\n  "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/5-test-driven-or-test-oriented/",
	"title": "Test driven or test oriented",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Test driven or test oriented In this chapter, we will look at two different approaches to writing unit tests.\n Test driven development (TDD) Test oriented development  I like to mix these two approaches depending on the situation.\n \rWatch video\r\r "
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/5-interface-segregation-principle/",
	"title": "Interface Segregation Principle",
	"tags": [],
	"description": "",
	"content": " \rWatch video\r\r Interface Segregation Principle(ISP) was introduced by Robert C. Martin. He says\n Clients should not be forced to depend on methods it does not use\n There may be scenarios where we may have a class that has members(fields, properties or methods) used by two or more clients. When changing any of the members used by one client, all the clients of the class, even the ones that are not using the changing members, are affected.\nRobert C. Martin describes these type of classes as Interface Pollution. In this context, interface refers to the public members (fields, properties and methods) of the class.\nAs per Interface Segregation Principle, we should have one interface per client with just enough members needed for that client.\nThis is better understood with an example. Let\u0026rsquo;s say we have Order class\npublic class Order { pubic void Create() { // create order for product(s)  } public void Update() { // update order  } public void Cancel() { // cancel order  } public void Return() { // return ordered product(s)  } public void Track() { // track order  } public void Process() { // process order  } public void Dispatch() { // dispatch order  } public void ProcessCancellation() { // process cancellation  } public void ProcessReturn() { // process return  } } This class clearly contains methods that are used by two different clients - Customer user interface and Seller user interface.\nWhile it is best to avoid this type of classes, it is not always possible.\nIn situations like this, it is a good idea to have client specific interface that exposes just enough members for each client.\nThe key benefit of having client specific interface are\n  it allows clients to see only what it needs to see so the collaboration between the class and the client is clear\n  it completely eliminates the chance of misuse. For example, Customer user interface calling Dispatch() method\n  Martin Fowler calls this type of interface as role interface\nIn our example, we will create the following two interfaces, one for each client, as per Interface Segregation Principle\npublic interface ICustomerOrder { void Create(); void Update(); void Cancel(); void Return(); void Track(); } public interface ISellerOrder { void Process(); void Dispatch(); void ProcessCancellation(); void ProcessReturn(); } The Order class still contains all the methods but it now implements both ICustomerOrder and ISellerOrder interfaces\npublic class Order : ICustomerOrder, ISellerOrder { pubic void Create() { // create order for product(s)  } public void Update() { // update order  } public void Cancel() { // cancel order  } public void Return() { // return ordered product(s)  } public void Track() { // track order  } public void Process() { // process order  } public void Dispatch() { // dispatch order  } public void ProcessCancellation() { // process cancellation  } public void ProcessReturn() { // process return  } } The customer user interface can use the ICustomerOrder abstraction rather than Order class directly. This way, customer user interface won\u0026rsquo;t see any methods that it should not use.\nLikewise, seller user interface can use ISellerOrder and it won\u0026rsquo;t see any methods that it should not use.\nReferences   https://drive.google.com/file/d/0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi/view\n  https://en.wikipedia.org/wiki/Interface_segregation_principle\n  "
},
{
	"uri": "https://kodebot.com/tutorials/automated-unit-testing-basics/1-introduction/5-system-under-test/",
	"title": "System Under Test (SUT)",
	"tags": [],
	"description": "",
	"content": "The implementation of System Under Test (SUT) that are the target of our unit test can be one of the following\n direct implementation indirect implementation combination of the above  Direct implementation If a function or piece of code is direct implementation, then it will take zero or more inputs and provide some results or cause state change with very little or no dependencies.\nExamples of direct implementation\n Functions that implement individual operations of a calculator program like addition, subtraction, etc\u0026hellip; Function that creates new student object Function that validates bank account number  Indirect implementation Normally a function or piece of code falls under this type when it gets something done via one or more of its dependencies rather than doing it on its own.\nExamples of indirect implementation\n Reading/writing data in database by calling functions in the database driver Validating the account number by calling a function that provides validation  Direct and indirect We will also come across many SUT where the implementation is combination of both direct and indirect\nIt is good to be aware of these types because we might need to use different techniques for testing depending on their implementation type.\n"
},
{
	"uri": "https://kodebot.com/tutorials/solid-principles/6-dependency-inversion-principle/",
	"title": "Dependency Inversion Principle",
	"tags": [],
	"description": "",
	"content": " \rWatch video\r\r Dependency Inversion Principle(DIP) is introduced by Robert C. Martin and his definition is\n A. High-level modules should not depend on low-level modules. Both should depend on abstractions.\n  B. Abstractions should not depend upon details. Details should depend upon abstractions.\n Let\u0026rsquo;s look at an example of hypothetical mortgage application system.\nWe have higher level Mortgage module with Application class and BureauData module at the next level with BureauDataProvider class and at lower level we have Utility module with DataCleaner class\nusing BureauData; namespace Mortgage { public class Application { public Application(BureauDataProvider dataProvider) { } } } using Utility; namespace BureauData { public class BureauDataProvider { public BureauDataProvider(DataCleaner dataCleaner) { } } } namespace Utility { public class DataCleaner { } } Here the higher level Application class directly depends on next level BureauDataProvider class and it directly depends on DataCleaner class in the lower level. Application class indirectly depends on DataCleaner. Now, changes to DataCleaner or BureauDataProvider class may directly affect Application class.\nThis is not a good situation. The higher level module should control the lower level module, not the other way around. Otherwise, changes in lower level classes would force changes on higher level classes and their consumers without adding any value.\nIn addition to this, when higher level classes directly depend on lower level classes, it is very difficult to reuse higher level classes in different context.\nWe can use Dependency Inversion Principle to address this issue. We first need to define the abstractions (interfaces) that higher level modules should work with then make the lower level modules implement them.\nHere is the revised example\nnamespace Mortgage { public interface IApplicationBureauDataProvider { } public class Application { public Application(IApplicationBureauDataProvider dataProvider) { } } } using Mortgage; namespace BureauData { public interface IDataCleaner { } public class BureauDataProvider : IApplicationBureauDataProvider { public BureauDataProvider(IDataCleaner dataCleaner) { } } } using BureauData; namespace Utility: IDataCleaner { public class DataCleaner { } } Now if we look at the Application class in Mortgage module, it depends on IApplicationBureauDataProvider interface which is defined in Mortgage module itself. So, Application class depends on the abstraction rather than the concrete implementation detail.\nThe BureauDataProvider class in BureauData module implements IApplicationBureauDataProvider from Mortgage module. So, the detail implementation class implements(depends on) the abstraction forced by higher level module.\nSimilarly, BureauDataProvider depends on IDataCleaner interface defined in BureauData module and DataCleaner class in Utility module is implementing IDataCleaner interface.\nAs we can see, the advantage of this design is that the changes to BureauDataProvider cannot affect Application because BureauDataProvider implements IApplicationBureauDataProvider and it cannot change the contract. Also, we can easily reuse Application class with another bureau data provider as long as the new bureau data provider implements IApplicationBureauDataProvider.\nIt is not necessary that the interfaces higher level module depend on should be packaged in the same module. It can be in different module as long it is owned by the higher level module (i.e. changed only when needed for higher level module).\n\rThis principle is also referred to as Hollywood Principle. This is because \u0026ldquo;Don\u0026rsquo;t call us, we will call you\u0026rdquo; phrase is used in Hollywood auditions and this is the communication pattern we achieve with Dependency Inversion Principle.\n\rReferences   https://en.wikipedia.org/wiki/Dependency_inversion_principle\n  Chapter 11, Agile Principles, Patterns, and Practices in C# by Robert C. Martin; Micah Martin\n  https://en.wiktionary.org/wiki/Hollywood_principle\n  "
},
{
	"uri": "https://kodebot.com/tags/.net/",
	"title": ".NET",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/c#/",
	"title": "C#",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2021/join-and-groupjoin-in-dotnet/",
	"title": "Join and GroupJoin in C#",
	"tags": ["C#", ".NET"],
	"description": "",
	"content": "Introduction Join and GroupJoin are two different methods that we can use in our LINQ query to join two different collections. At first glance, they might look similar but they produce different results. Lets look at how they work with an example.\nExample setup For our example, we are going to use the following Student and Enrolment class.\nclass Student { public string Id { get; set; } public string Name { get; set; } } class Enrolment { public string Id { get; set; } public string StudentId { get; set; } } And we assume, we have the following data\nvar students = new List\u0026lt;Student\u0026gt; { new Student {Id = \u0026#34;s1\u0026#34;, Name = \u0026#34;Foo\u0026#34;}, new Student {Id = \u0026#34;s2\u0026#34;, Name = \u0026#34;Bar\u0026#34;}, new Student {Id = \u0026#34;s3\u0026#34;, Name = \u0026#34;Cux\u0026#34;} }; var enrolments = new List\u0026lt;Enrolment\u0026gt; { new Enrolment {Id = \u0026#34;e1\u0026#34;, StudentId = \u0026#34;s1\u0026#34;}, new Enrolment {Id = \u0026#34;e2\u0026#34;, StudentId = \u0026#34;s1\u0026#34;}, new Enrolment {Id = \u0026#34;e1\u0026#34;, StudentId = \u0026#34;s2\u0026#34;}, }; Here, student s1 has more than one enrolments and s2 has one enrolment and s3 has none.\nJoin Join basically creates a new collection by taking each item from first collection and combining it with each item on the second collection where the join conditions are met.\nFor example,\nstudents.Join( enrolments, s =\u0026gt; s.Id, e =\u0026gt; e.StudentId, (s, e) =\u0026gt; new { Student = s.Id, Enrolment = e.Id }); Query version\nfrom s in students join e in enrolments on s.Id equals e.StudentId select new { Student = s.Id, Enrolment = e.Id }; produces\n[ { \u0026#34;Student\u0026#34;: \u0026#34;s1\u0026#34;, \u0026#34;Enrolment\u0026#34;: \u0026#34;e1\u0026#34; }, { \u0026#34;Student\u0026#34;: \u0026#34;s1\u0026#34;, \u0026#34;Enrolment\u0026#34;: \u0026#34;e2\u0026#34; }, { \u0026#34;Student\u0026#34;: \u0026#34;s2\u0026#34;, \u0026#34;Enrolment\u0026#34;: \u0026#34;e1\u0026#34; } ] Here, we have two items for student s1 because s1 has two enrolments, one item for s2 and no item for s3 as s3 has no enrolments.\nThis very similar to inner join in SQL.\nGroupJoin GroupJoin takes each item from the first collection, finds all items from the second collection where join conditions are met and combines them. This means, the result collection will have same number of entries as first collection and each item from the first collection may have zero or more associated items from second collection.\nFor example,\nstudents.GroupJoin( enrolments, s =\u0026gt; s.Id, e =\u0026gt; e.StudentId, (s, es) =\u0026gt; new { Student = s.Id, Enrolments = es.Select(e =\u0026gt; e.Id) }); Query version\nfrom s in students join e in enrolments on s.Id equals e.StudentId into joined select new { Student = s.Id, Enrolment = joined.Select(j =\u0026gt; j.Id) }; produces\n[ { \u0026#34;Student\u0026#34;: \u0026#34;s1\u0026#34;, \u0026#34;Enrolments\u0026#34;: [ \u0026#34;e1\u0026#34;, \u0026#34;e2\u0026#34; ] }, { \u0026#34;Student\u0026#34;: \u0026#34;s2\u0026#34;, \u0026#34;Enrolments\u0026#34;: [ \u0026#34;e1\u0026#34; ] }, { \u0026#34;Student\u0026#34;: \u0026#34;s3\u0026#34;, \u0026#34;Enrolments\u0026#34;: [] } ] Here, we have three items in the result collection - same number of items as first collection(one for each student). But, s1 has two enrolments, s2 has one and s3 has no enrolments. Note, even though there is no matching enrolment for s3, we still have it in the result but no items in enrolments.\nThis is similar to left outer join in SQL.\n"
},
{
	"uri": "https://kodebot.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/linux/",
	"title": "linux",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/one-minute-guide/",
	"title": "one-minute-guide",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2021/tmux-one-minute-guide/",
	"title": "tmux One Minute Guide",
	"tags": ["one-minute-guide", "linux", "ubuntu"],
	"description": "",
	"content": "What is tmux? tmux is terminal multiplexer that allows your terminal to be split into different sessions, windows and panes. One of the great thing about tmux is that, you can detach from and reattach to, tmux sessions without terminating the programs running in those sessions.\nSession - is a wrapper for your windows and panes that you can create, detach from and reattach to without terminating the programs running in the sessions\nIt is obvious but just so it is clear, you will lose the sessions and programs running in those sessions on reboot.\n\rWindow - is like tabs within a session, you can switch between them but you can only see one window at a time by default\nPane - is a region in the window. By default each with comes with 1 pane. You can add additional horizontal and/or vertical panes as you like\nOne minute guide Install sudo apt install tmux Create session (default) tmux Create session with a name tmux new -s \u0026lt;session-name\u0026gt; Frequently used commands    Command What it does?     Press Ctrl + b then press c immediately Creates new window   Press Ctrl + b then press \u0026lt;window-number\u0026gt; immediately Switch between windows. For example, Ctrl + b then 1 to switch to window 1   Press Ctrl + b then press , immediately Allows you to change name of the window   Press Ctrl + b then press \u0026quot; immediately Splits the screen vertically [-] by creating a new pane   Press Ctrl + b then press % immediately Splits the screen horizontally [ l ] by creating a new pane   Press Ctrl + b then press \u0026lt;arrow-key\u0026gt; immediately Switching between panes. Takes you to the pane in present in the direction of the arrow key you pressed   Press and hold Ctrl + b then press \u0026lt;arrow-key\u0026gt; Resize pane. Changes the size of the pane based on the arrow key you press   Press Ctrl + b then press d immediately Detach from current session   tmux ls List tmux sessions   tmux attach-session -t  Attach to existing session. For example, tmux attach-session -t 0 attaches to session 0   tmux rename-session -t  Rename session. For example, tmux rename-session -t 0 git renames session 0 to git   exit Closes pane, window or a session depending on the context    "
},
{
	"uri": "https://kodebot.com/tags/ubuntu/",
	"title": "ubuntu",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tutorials/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": "\r\rAutomated unit testing basics\r\r\rSOLID Principles\r\r\r"
},
{
	"uri": "https://kodebot.com/tags/javascript/",
	"title": "JavaScript",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/nodejs/",
	"title": "NodeJS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/nodejs-loops/",
	"title": "NodeJs: Loops, Closure and Async Invocation",
	"tags": ["NodeJS", "JavaScript"],
	"description": "",
	"content": "Closure Closure is something that is very familiar to all C# developers who know lambda expressions/functions but they just may not know that it is called Closure in JavaScript.\nLets look at what is closure in JavaScript without further ado with an example:\nfunction outer(){ var inOuter = \u0026#34;outer\u0026#34;; inner(); function inner(){ console.log(inOuter); // prints \u0026#39;outer\u0026#39; \t} } In this example, the variable inOuter is defined in the function outer but it is used in the function inner. This is possible because, the a function in JavaScript can access all the variables in the scope where the function is defined and this is called Closure.\nLoop and Closure Lets consider the following example:\nfunction outer(){ for(var i=1; i\u0026lt;=5; i++){ inner(); } function inner(){ console.log(i); // prints 1, 2, 3, 4, 5 \t} } Here the function inner is called from a loop and iterator variable is printed from inside the function inner. It prints, as you guessed, 1, 2, 3, 4, 5. This is because the function inner get the value of i whatever it is when the function inner is invoked.\nLoop, Closure and async invocation Lets look at what happens if we invoke the function inner asynchronously\nfunction outer(){ for(var i=1; i\u0026lt;=5; i++){ process.nextTick(inner); // We can use setImmediate or setTimeout in browser environment to get similar effect \t} function inner(){ console.log(i); // prints 6, 6, 6, 6, 6 \t} } You may not expect it to print 6, 6, 6, 6, 6 but that\u0026rsquo;s what it does. This is because the loop runs to completion in the current tick and the function inner is only invoked in some tick down the line. So, the value of i will be 6 when function inner is executed and it prints 6.\nNow, what do you do if you want to print 1, 2, 3, 4, 5 instead of 6, 6, 6, 6, 6?\nWell, it turns out, you can do this simply by creating new function to create a new variable scope. This is because, in JavaScript variables are scoped to function instead of block.\n Note: Starting ES2015, you can use let instead of var to create block scope.\n Here is the revised code:\nfunction outer(){ for(var i=1; i\u0026lt;=5; i++){ process.nextTick((function(){ var j = i; return inner;\tfunction inner(){ console.log(j); // prints 1, 2, 3, 4, 5 \t} })()); } } We have created a new scope and assigned value of i to j which is defined in the new scope. We have also moved the function inner to the new scope.\nThat\u0026rsquo;s it, now it prints what we want it to print.\n"
},
{
	"uri": "https://kodebot.com/blog/2015/exception-handling-in-nodejs/",
	"title": "Exception Handling in NodeJS",
	"tags": ["NodeJS", "JavaScript"],
	"description": "",
	"content": "Introduction Exception handling in Node might look completely different for developers coming from C# background like myself. It is mainly because of the way Node works. Node uses single thread based event loop to enable concurrency, this results in higher throughput with relatively low overhead. When it comes to exception handling, having some understanding of the event loop will help you to do the right thing.\nEvent Loop Node has the following three main components to achieve concurrent, non-blocking execution\n1. Event Demultiplexer\n2. Event Loop\n3. Event Queue\nTo put it simply, any function/piece of code which depends on time consuming, non-cpu intensive I/O operation registers itself with Event Demultiplexer along with a handler. Event demultiplexer deals with the underlying I/O operation and when the data is available to process, it adds the registered event to the Event Queue to make the data available for further processing. The Event Loop simply dequeue the event and runs its associated handler.\nSynchronous Block Now, with the high level understanding of how Node\u0026rsquo;s Event Loop works, we will look at how exception handling works in a synchronous block of code.\nIf you don\u0026rsquo;t wrap your exception prone code in try..catch block then the exception would simply reach event loop and your app will crash. Any exception reaching event loop would simply result in application crash, it\u0026rsquo;s that simple. This means, if you want to provide nice user experience you have to handle the exception properly. For, synchronous block of code, this is as simple as wrapping your code in try..catch and do whatever you want to do in the catch block.\nYou should not let the exception bubble up using throw to avoid it reaching event loop and application crash.\n\rfunction divide(x, y){ try{ return x/y; } catch(e){ console.log(\u0026#34;Error::\u0026#34; + e.message); return 0; } } In this, example the message is displayed in the console and value 0 is returned from the catch block.\nAsynchronous Block Node is known for it callbacks. These callbacks are nothing but the handlers that are registered with Event Demultiplexer. Because these handlers/callbacks are executed directly by event loop, we need to wrap anything and everything in the try..catch block to make sure the exception is not reaching the event loop.\nvar fs = require(\u0026#39;fs\u0026#39;); var path = \u0026#39;C:\\temp\\tempFile.txt\u0026#39;; try{ fs.stat(path, statCallback);\t} catch(e){ console.log(\u0026#34;Error::\u0026#34; + e.message); return; } function statCallback(err, stats){ try{ return stats.isFile(); } catch(e){ console.log(\u0026#34;Error::\u0026#34; + e.message); return false; } } If you look at the example above, the we use two try..catch blocks one for the code around fs.stat() and another one is inside the callback function. This is required because, as we saw earlier the callback is executed directly by the event loop so any unhandled exceptions in the callback will reach event loop.\nThis will be annoying when we have nested callbacks as we need to wrap each callback in its own try..catch block.\nNode provides domain to make this process simple but it is deprecated at the moment in favour of better solution which is not available yet.\nUnhandled Exceptions When event loop encounters any unhandled exceptions, it emits uncaughtException. We can use this to log the error before let the application crash.\nprocess.on(\u0026#39;uncaughtException\u0026#39;, function(err){ console.log(err); }); You can find lot more information on this topic here, including event emitters - which is not covered in this post, in the official documentation.\n"
},
{
	"uri": "https://kodebot.com/tags/entity-framework/",
	"title": "entity framework",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/unit-testing/",
	"title": "Unit Testing",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/unit-testing-entity-framework-async-queries/",
	"title": "Unit Testing Entity Framework async Queries",
	"tags": ["Unit Testing", "entity framework"],
	"description": "",
	"content": "Introduction In my last article, we have seen how to unit test Entity Framework queries. Now, let\u0026rsquo;s look at how to unit test async queries. When using async tasks, if we don\u0026rsquo;t use it all the way then we are not using async tasks properly. For example, if you have async action method in your controller which queries database synchronously to send some data to the requester, then we are NOT using async properly as the thread is blocked during database operation. So, to take full advantage of async tasks, we have to use async tasks all the way wherever it is applicable. Fortunately, we get async query support starting from Entity Framework 6.\nAsync Queries Let\u0026rsquo;s take the query we have written last time and convert it into async.\npublic IQueryable\u0026lt;Movie\u0026gt; GetTopFiveMovies(int year) { return _moviesContext.Movies .Where(movie =\u0026gt; movie.Year == year) .OrderByDescending(movie =\u0026gt; movie.Rating) .Take(5); } The above method takes the top five movies for a given year synchronously. To change this to run asynchronously, we need to force the query execution using ToListAsync() extension method. The async version of the method would look like this\npublic async Task\u0026lt;List\u0026lt;Movie\u0026gt;\u0026gt; GetTopFiveMovies(int year) { return await _moviesContext.Movies .Where(movie =\u0026gt; movie.Year == year) .OrderByDescending(movie =\u0026gt; movie.Rating) .Take(5) .ToListAsync(); } Unit Testing In order to replace underlying data source with in-memory list, the list should implement IDbAsyncEnumerable and IQueryable. We can simply convert List into IQueryable using AsQueryable() extension method. But it is not straight forward to implement IDbAsyncEnumerable. The easiest way to acheive this is by wrapping our List data in a class which implements IDbAsyncEnumerable.\nThe class we create implementing IDbAsyncEnumerable should have GetAsyncEnumerator() method returning an enumerator implementing IDbAsyncEnumerator and Provider property should return a QueryProvider which implements IDbAsyncQueryProvider. So we need three fake/test-double classes as follows\npublic class FakeDbAsyncEnumerable\u0026lt;T\u0026gt; : EnumerableQuery\u0026lt;T\u0026gt;, IDbAsyncEnumerable\u0026lt;T\u0026gt;, IQueryable\u0026lt;T\u0026gt; { public FakeDbAsyncEnumerable(IEnumerable\u0026lt;T\u0026gt; enumerable) : base(enumerable) { } public FakeDbAsyncEnumerable(Expression expression) : base(expression) { } public IDbAsyncEnumerator\u0026lt;T\u0026gt; GetAsyncEnumerator() { return new FakeDbAsyncEnumerator\u0026lt;T\u0026gt;(this.AsEnumerable().GetEnumerator()); } IDbAsyncEnumerator IDbAsyncEnumerable.GetAsyncEnumerator() { return GetAsyncEnumerator(); } IQueryProvider IQueryable.Provider { get { return new FakeDbAsyncQueryProvider\u0026lt;T\u0026gt;(this); } } } public class FakeDbAsyncEnumerator\u0026lt;T\u0026gt; : IDbAsyncEnumerator\u0026lt;T\u0026gt; { private readonly IEnumerator\u0026lt;T\u0026gt; _localEnumerator; public FakeDbAsyncEnumerator(IEnumerator\u0026lt;T\u0026gt; localEnumerator) { _localEnumerator = localEnumerator; } public void Dispose() { _localEnumerator.Dispose(); } public Task\u0026lt;bool\u0026gt; MoveNextAsync(CancellationToken cancellationToken) { return Task.FromResult(_localEnumerator.MoveNext()); } public T Current { get { return _localEnumerator.Current; } } object IDbAsyncEnumerator.Current { get { return Current; } } } public class FakeDbAsyncQueryProvider\u0026lt;T\u0026gt; : IDbAsyncQueryProvider { private readonly IQueryProvider _localQueryProvider; internal FakeDbAsyncQueryProvider(IQueryProvider localQueryProvider) { _localQueryProvider = localQueryProvider; } public IQueryable CreateQuery(Expression expression) { return new FakeDbAsyncEnumerable\u0026lt;T\u0026gt;(expression); } public IQueryable\u0026lt;TElement\u0026gt; CreateQuery\u0026lt;TElement\u0026gt;(Expression expression) { return new FakeDbAsyncEnumerable\u0026lt;TElement\u0026gt;(expression); } public object Execute(Expression expression) { return _localQueryProvider.Execute(expression); } public TResult Execute\u0026lt;TResult\u0026gt;(Expression expression) { return _localQueryProvider.Execute\u0026lt;TResult\u0026gt;(expression); } public Task\u0026lt;object\u0026gt; ExecuteAsync(Expression expression, CancellationToken cancellationToken) { return Task.FromResult(Execute(expression)); } public Task\u0026lt;TResult\u0026gt; ExecuteAsync\u0026lt;TResult\u0026gt;(Expression expression, CancellationToken cancellationToken) { return Task.FromResult(Execute\u0026lt;TResult\u0026gt;(expression)); } } Now, we just need to create our data list and wrap it in FakeDbAsyncEnumerable instance and replace all the properties used by LINQ in DbSet instance with the one from FakeDbAsyncEnumerable. Note, because we are using async query, we need to setup create setup to replace GetAsyncEnumerator rather than GetEnumerator.\nThe completed unit test would look like this\n[TestMethod] public async Task GetTopFiveMoviesShouldReturnTopFiveMoviesSuccessfully() { // Fixture Setup  int year = 1999; // test movie list data  var movieList = new List\u0026lt;Movie\u0026gt; { new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =5, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =5, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =4, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =1, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =2, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =4, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =4, Year=1991 } }; // mock DbSet  var fakeAsynEnumerable = new FakeDbAsyncEnumerable\u0026lt;Movie\u0026gt;(movieList); var mockDbSetMovies = new Mock\u0026lt;IDbSet\u0026lt;Movie\u0026gt;\u0026gt;(); mockDbSetMovies.As\u0026lt;IQueryable\u0026gt;() .Setup(mock =\u0026gt; mock.Provider) .Returns(fakeAsynEnumerable.AsQueryable().Provider); mockDbSetMovies.As\u0026lt;IQueryable\u0026gt;() .Setup(mock =\u0026gt; mock.Expression) .Returns(fakeAsynEnumerable.AsQueryable().Expression); mockDbSetMovies.As\u0026lt;IQueryable\u0026gt;() .Setup(mock =\u0026gt; mock.ElementType) .Returns(fakeAsynEnumerable.AsQueryable().ElementType); mockDbSetMovies.As\u0026lt;IDbAsyncEnumerable\u0026gt;() .Setup(mock =\u0026gt; mock.GetAsyncEnumerator()) .Returns(((IDbAsyncEnumerable\u0026lt;Movie\u0026gt;)fakeAsynEnumerable).GetAsyncEnumerator()); // mock DbContext  var mockMovieContext = new Mock\u0026lt;IMoviesContext\u0026gt;(); mockMovieContext.Setup(mock =\u0026gt; mock.Movies).Returns(mockDbSetMovies.Object); var sut = new MovieFinder(mockMovieContext.Object); // Exercise System  var result = await sut.GetTopFiveMovies(year); // Verify Outcome  Assert.AreEqual(5, result.Count()); Assert.IsTrue(result.All(item =\u0026gt; item.Year == year)); // Fixture Teardown } "
},
{
	"uri": "https://kodebot.com/blog/2015/unit-testing-entity-framework-queries/",
	"title": "Unit Testing Entity Framework Queries",
	"tags": ["Unit Testing", "entity framework"],
	"description": "",
	"content": "Introduction When writing unit tests, we should test only one thing at once and isolate the system under test(SUT) from all the dependencies. We should follow the same approach for any LINQ queries you write to retrieve data from the underlying Database. But, I have seen many developers excluding the whole data access layer from unit testing. This is not right approach to follow IMHO. Many developers don\u0026rsquo;t bother unit testing data access layer because of the perceived effort and complexity involved in isolating the data access layer from underlying Database and ORM tools like Entity Framework. The truth is, it is very easy to test your queries without touching Entity Framework or Database.\nDataContext, DbSet and Finder Let\u0026rsquo;s assume that we have Movies database with Movie table and we want to write some queries to get top 5 movies released in year 1999. The default DbContext for this database would look like this\npublic class MoviesContext : DbContext { public MoviesContext() : base(\u0026#34;name=MoviesEntities\u0026#34;) { } public virtual DbSet\u0026lt;Movie\u0026gt; Movies { get; set; } } First, we need to make two changes to isolate this DbContext from unit testing\nYou should not create instance of DbContext directly, instead use your faviroute DI Framework to inject it as dependency when requested.\n\rUpdated DbContext class and interface should look like this\npublic class MoviesContext : DbContext, IMoviesContext { public MoviesContext() : base(\u0026#34;name=MoviesEntities\u0026#34;) { } public virtual IDbSet\u0026lt;Movie\u0026gt; Movies { get; set; } } public interface IMoviesContext { IDbSet\u0026lt;Movie\u0026gt; Movies { get; set; } } Now, let\u0026rsquo;s create a MovieFinder with a method GetTopFiveMovies to return top 5 movies for a given year as follows\npublic class MovieFinder { private readonly IMoviesContext _moviesContext; public MovieFinder(IMoviesContext moviesConext) { _moviesContext = moviesConext; } public IQueryable\u0026lt;Movie\u0026gt; GetTopFiveMovies(int year) { return _moviesContext.Movies .Where(movie =\u0026gt; movie.Year == year) .OrderByDescending(movie =\u0026gt; movie.Rating) .Take(5); } } Unit Testing To write unit tests for GetTopFiveMovies, we need to mock MoviesContext to provide testable implementation for Movies properties. For this example, I am going to use Moq but you can use any mocking framework you like. The completed unit test method would look like this\n[TestClass] public class MovieFinderTests { [TestMethod] public void GetTopFiveMoviesShouldReturnTopFiveMoviesSuccessfully() { // Fixture Setup  int year = 1999; // test movie list data  var movieList = new List\u0026lt;Movie\u0026gt; { new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =5, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =5, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =4, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =1, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =2, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =4, Year=1999 }, new Movie() {Id =1, Name=\u0026#34;Test1\u0026#34;, Rating =4, Year=1991 } }; // mock DbSet  var mockDbSetMovies = new Mock\u0026lt;IDbSet\u0026lt;Movie\u0026gt;\u0026gt;(); mockDbSetMovies.Setup(mock =\u0026gt; mock.Provider).Returns(movieList.AsQueryable().Provider); mockDbSetMovies.Setup(mock =\u0026gt; mock.Expression).Returns(movieList.AsQueryable().Expression); mockDbSetMovies.Setup(mock =\u0026gt; mock.ElementType).Returns(movieList.AsQueryable().ElementType); mockDbSetMovies.Setup(mock =\u0026gt; mock.GetEnumerator()).Returns(movieList.GetEnumerator()); // mock DbContext  var mockMovieContext = new Mock\u0026lt;IMoviesContext\u0026gt;(); mockMovieContext.Setup(mock =\u0026gt; mock.Movies).Returns(mockDbSetMovies.Object); var sut = new MovieFinder(mockMovieContext.Object); // Exercise System  var result = sut.GetTopFiveMovies(year); // Verify Outcome  Assert.AreEqual(5, result.Count()); Assert.IsTrue(result.All(item =\u0026gt; item.Year == year)); // Fixture Teardown  } } First, we are creating test movie data and then a mock DbSet\u0026lt;Movie\u0026gt; is created. The value of properties used by LINQ to support querying (Provider, Expression, ElementType) are replaced by the values from test data list movieList. Then, enumerator of DbSet is assigned to the enumerator of test data list movieList. Finally, the mock DbContext returns the mock DbSet\u0026lt;Movie\u0026gt; when Movie property is accessed.\nWith this setup, we are providing in-memory test data to execute our query without touching EF or database.\n"
},
{
	"uri": "https://kodebot.com/tags/apache-cordova/",
	"title": "Apache Cordova",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/apps/",
	"title": "Apps",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/vs-tac-cordova-version/",
	"title": "VS-TAC - Cordova version",
	"tags": ["Apps", "Apache Cordova"],
	"description": "",
	"content": "The important thing to understand is that Visual Studio is not doing anything like MSBuild, instead it just uses core cordova tool to build and deploy your application.In the application I was developing, I wanted to use one of the Cordova plugin from npm. Cordova plugins are being migrated to npm and old plugins are also available in cordova’s old registry.If you want to use plugins from npm, your cordova cli version must be 5.0.0 or higher. VS 2015 RC currently uses version 4.3.0 which doesn’t support plugins from npm. So, you need to upgrade the version of cordova-cli Visual Studio uses.It is very simple to upgrade the version of cordova tools Visual Studio uses. All you need to do is, open up the config.xml in designer and update the cordova cli version in platforms tab"
},
{
	"uri": "https://kodebot.com/tags/asp.net/",
	"title": "ASP.NET",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/aspnet-mvc-5-jsonresult-with-http-status-code-400/",
	"title": "ASP.NET MVC 5 - JsonResult with Http Status Code 400",
	"tags": ["ASP.NET", "MVC"],
	"description": "",
	"content": "ASP.NET Web API 2 introduced several helper methods like Ok, NotFound, BadRequest, etc… . This allows us to write code which makes its intentions clear.\nIn recent times, I have been working in semi-single page application which uses ASP.NET MVC 5 and AngularJS. The application is designed in a way that, there is only one view per feature and each view is SPA. So, each ASP.NET MVC controller have only one GET action that returns the view and rest of the communication is using actions that returns JsonResult that can be used by client in AJAX style just like consuming Web API. With this design, I have to send JsonResult for everything, but, the Http Status Code has to be set appropriately so that the client can use them for any processing that it needs to do based on the Status Code.\nFirst, I set the status code directly in Response in the action method and then returned JsonResult like this:\nResponse.StatusCode = 400; return Json(data); public class BadRequest : JsonResult { public BadRequest() { } public BadRequest(string message) { this.Data = message; } public BadRequest(object data) { this.Data = data; } public override void ExecuteResult(ControllerContext context) { context.RequestContext.HttpContext.Response.StatusCode = 400; base.ExecuteResult(context); } } [HttpPost] public ActionResult Add(Author author, HttpPostedFileBase photoContent) { if (author == null) { return new BadRequest(\u0026#34;Invalid author details.\u0026#34;); } . . . } "
},
{
	"uri": "https://kodebot.com/tags/mvc/",
	"title": "MVC",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/angularjs/",
	"title": "AngularJS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/angularjs-1x-validation-on-file-input-type/",
	"title": "AngularJS 1.x - Validation on File Input type",
	"tags": ["JavaScript", "AngularJS"],
	"description": "",
	"content": "\u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;col-md-2 control-label\u0026#34; for=\u0026#34;photoUrl\u0026#34;\u0026gt;Photo\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;btn btn-primary btn-file input-group-addon\u0026#34;\u0026gt; Browse \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;photoUrlSelector\u0026#34; name=\u0026#34;photoUrlSelector\u0026#34; accept=\u0026#34;image/*\u0026#34; \u0026gt; \u0026lt;/span\u0026gt; \u0026lt;input class=\u0026#34;form-control\u0026#34; type=\u0026#34;text\u0026#34; id=\u0026#34;photoUrl\u0026#34; name=\u0026#34;photoUrl\u0026#34; data-ng-disabled=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span class=\u0026#34;btn btn-primary btn-file input-group-addon\u0026#34;\u0026gt; Browse \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;photoUrlSelector\u0026#34; name=\u0026#34;photoUrlSelector\u0026#34; accept=\u0026#34;image/*\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;btn btn-primary btn-file input-group-addon\u0026quot;\u0026gt;\rBrowse \u0026lt;input type=\u0026quot;file\u0026quot; id=\u0026quot;photoUrlSelector\u0026quot; name=\u0026quot;photoUrlSelector\u0026quot; ngf-select ng-model=\u0026quot;vm.author.photoUrl\u0026quot; accept=\u0026quot;image/*\u0026quot; data-ng-click=\u0026quot;addAuthorForm.photoUrl.$touched=true\u0026quot;\u0026gt;\r\u0026lt;/span\u0026gt;\r\u0026lt;input class=\u0026#34;form-control\u0026#34; type=\u0026#34;text\u0026#34; id=\u0026#34;photoUrl\u0026#34; name=\u0026#34;photoUrl\u0026#34; data-ng-model=\u0026#34;vm.author.photoUrl[0].name\u0026#34; data-ng-required=\u0026#34;true\u0026#34; data-ng-disabled=\u0026#34;true\u0026#34;\u0026gt; as you can see, the input field is also decorated with ng-required directive to enforce required field validation.\n\u0026lt;div class=\u0026#34;form-group has-feedback\u0026#34; data-ng-class=\u0026#34;{\u0026#39;has-error\u0026#39;:addAuthorForm.photoUrl.$invalid \u0026amp;\u0026amp; addAuthorForm.photoUrl.$touched, \u0026#39;has-success\u0026#39;:addAuthorForm.photoUrl.$valid \u0026amp;\u0026amp; addAuthorForm.photoUrl.$touched}\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;col-md-2 control-label\u0026#34; for=\u0026#34;photoUrl\u0026#34;\u0026gt;Photo\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;btn btn-primary btn-file input-group-addon\u0026#34;\u0026gt; Browse \u0026lt;input type=\u0026#34;file\u0026#34; id=\u0026#34;photoUrlSelector\u0026#34; name=\u0026#34;photoUrlSelector\u0026#34; ngf-select ng-model=\u0026#34;vm.author.photoUrl\u0026#34; accept=\u0026#34;image/*\u0026#34; data-ng-click=\u0026#34;addAuthorForm.photoUrl.$touched=true\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;input class=\u0026#34;form-control\u0026#34; type=\u0026#34;text\u0026#34; id=\u0026#34;photoUrl\u0026#34; name=\u0026#34;photoUrl\u0026#34; data-ng-model=\u0026#34;vm.author.photoUrl[0].name\u0026#34; data-ng-required=\u0026#34;true\u0026#34; data-ng-disabled=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;span data-ng-if=\u0026#34;addAuthorForm.photoUrl.$invalid \u0026amp;\u0026amp; addAuthorForm.photoUrl.$touched\u0026#34; class=\u0026#34;glyphicon glyphicon-remove form-control-feedback\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span data-ng-if=\u0026#34;addAuthorForm.photoUrl.$valid \u0026amp;\u0026amp; addAuthorForm.photoUrl.$touched\u0026#34; class=\u0026#34;glyphicon glyphicon-ok form-control-feedback\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span class=\u0026#34;help-block\u0026#34;\u0026gt; \u0026lt;span data-ng-show=\u0026#34;addAuthorForm.photoUrl.$error.required \u0026amp;amp;\u0026amp;amp; addAuthorForm.photoUrl.$touched\u0026#34;\u0026gt;The Photo is required field.\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; "
},
{
	"uri": "https://kodebot.com/blog/2015/angular-1x-unit-testing-a-function-that-returns-promise/",
	"title": "Angular 1.x - Unit Testing a function that returns Promise",
	"tags": ["AngularJS", "JavaScript", "Unit Testing"],
	"description": "",
	"content": "var app = angular.module(\u0026#34;app\u0026#34;); app.controller(\u0026#34;studentController\u0026#34;, function($q, studentDataService){ var vm = this; vm.students = undefined; activate(); function activate (){ vm.students = getAllStudents(); } function getAllStudents(){ return studentDataService .getAll(); } }); it(\u0026#34;should get students on activation\u0026#34;, function(done){ // Fixture Setup  // Exercise Systcode  var sut = $controller(\u0026#34;studentController\u0026#34;); // Verify Outcome  sut.students.then(function(data){ expect(data).toBeDefined(); done(); }); $rootScope.$apply(); // Fixture Teardown }); "
},
{
	"uri": "https://kodebot.com/tags/typescript/",
	"title": "TypeScript",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/typescript-accessing-object-with-null-key/",
	"title": "TypeScript - Accessing object with null key",
	"tags": ["TypeScript"],
	"description": "",
	"content": "var car = { wheels : 3, colour: \u0026#39;red\u0026#39;, drive: function(){ ... } } routes[null].redirectTo An index expression argument must be of type string, number, symbol, or any.\nvar nullRef: any = null; routes[nullRef].redirectTo "
},
{
	"uri": "https://kodebot.com/blog/2015/aspnet-mvc-5-hosting-for-integration-e2e-testing/",
	"title": "ASP.NET MVC 5 Hosting for Integration / E2E Testing",
	"tags": ["ASP.NET", "MVC"],
	"description": "",
	"content": "public static class ApplicationUtilities { private static Process _webHostProcess; private const string WEB_APP_NAME = \u0026#34;BookShop.Web\u0026#34;; private const int WEB_APP_PORT = 12345; public static void StartApplication() { var webHostStartInfo = GetProcessStartInfo(); _webHostProcess = Process.Start(webHostStartInfo); _webHostProcess.TieLifecycleToParentProcess(); } public static void StopApplication() { if (_webHostProcess == null) return; if (!_webHostProcess.HasExited) _webHostProcess.Kill(); _webHostProcess.Dispose(); } public static string ApplicationBaseUrl { get { return string.Format(\u0026#34;http://localhost:{0}\u0026#34;, WEB_APP_PORT); } } public static string GetFullUrl(string relativePath) { return string.Format(\u0026#34;{0}{1}\u0026#34;, ApplicationUtilities.ApplicationBaseUrl, relativePath); } private static string GetSolutionFolderPath() { var directory = new DirectoryInfo(Environment.CurrentDirectory); while (directory.GetFiles(\u0026#34;*.sln\u0026#34;).Length == 0) { directory = directory.Parent; } return directory.FullName; } private static ProcessStartInfo GetProcessStartInfo() { var key = Environment.Is64BitOperatingSystem ? \u0026#34;programfiles(x86)\u0026#34; : \u0026#34;programfiles\u0026#34;; var programfiles = Environment.GetEnvironmentVariable(key); var startInfo = new ProcessStartInfo { WindowStyle = ProcessWindowStyle.Normal, ErrorDialog = true, LoadUserProfile = true, CreateNoWindow = false, UseShellExecute = false, Arguments = String.Format(\u0026#34;/path:\\\u0026#34;{0}\\\u0026#34; /port:{1}\u0026#34;, Path.Combine(GetSolutionFolderPath(), @\u0026#34;src\\\u0026#34; + WEB_APP_NAME), WEB_APP_PORT), FileName = string.Format(\u0026#34;{0}\\\\IIS Express\\\\iisexpress.exe\u0026#34;, programfiles) }; // Add any environment variables  // startInfo.EnvironmentVariables.Add(key, value);  return startInfo; } } "
},
{
	"uri": "https://kodebot.com/blog/2015/how-to-mock-automapper-in-unit-tests/",
	"title": "How to isolate AutoMapper in Unit Tests?",
	"tags": ["Unit Testing", "Library"],
	"description": "",
	"content": "kernel.Bind\u0026lt;IMappingEngine\u0026gt;().ToConstant(Mapper.Engine); services.AddInstance\u0026lt;IMappingEngine\u0026gt;(Mapper.Engine); var mockMapper = new Mock\u0026lt;IMappingEngine\u0026gt;(); mockMapper.Setup(mock =\u0026gt; mock.Map\u0026lt;TargetType\u0026gt;(It.IsAny\u0026lt;SourceType\u0026gt;())).Returns(targetInstance); public class User { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public int Age { get; set; } } public class UserDto { public int Id { get; set; } public string FirstName { get; set; } } public class Sut { private readonly IMappingEngine _mapper; public Sut(IMappingEngine mapper) { _mapper = mapper; } public User Run(UserDto dto) { return _mapper.Map\u0026lt;User\u0026gt;(dto); } } public class SutTests { [Fact] public void RunShouldReturnUserCorrectly() { // arrange  var stubUser = new User(); var stubUserDto = new UserDto(); var mockMapper = new Mock\u0026lt;IMappingEngine\u0026gt;(); mockMapper.Setup(mock =\u0026gt; mock.Map\u0026lt;User\u0026gt;(It.Is\u0026lt;UserDto\u0026gt;(stubUserDto))).Returns(stubUser); var target = new Sut(mockMapper.Object); // act  var actual = target.Run(stubUserDto); // assert  Assert.AreEquals(stubUser, actual); } } "
},
{
	"uri": "https://kodebot.com/tags/library/",
	"title": "Library",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/asp-net-5-tag-helpers-the-html-way/",
	"title": "ASP.NET 5 - Tag Helpers, the HTML way",
	"tags": ["ASP.NET", "MVC"],
	"description": "",
	"content": "// Old style tag helpers @Html.LabelFor(Model =\u0026gt; Model.Name, \u0026#34;User Name\u0026#34;, new { @class = \u0026#34;control-label\u0026#34; }); // Declarative style \u0026lt;label asp-for=\u0026#34;Name\u0026#34; class=\u0026#34;control-label\u0026#34;\u0026gt;User Name\u0026lt;/label\u0026gt; // add tag helpers @addTagHelper \u0026#34;*, Microsoft.AspNet.Mvc.TagHelpers\u0026#34; // ITagHelper int Order { get; } Task ProcessAsync(TagHelperContext context, TagHelperOutput output); // Custom tag helper example [TargetElement(\u0026#34;div\u0026#34;, Attributes = \u0026#34;panel-title\u0026#34;)] [TargetElement(\u0026#34;div\u0026#34;, Attributes = \u0026#34;panel-style\u0026#34;)] public class PanelTagHelper : TagHelper { [HtmlAttributeName(\u0026#34;panel-title\u0026#34;)] public string Title { get; set; } [HtmlAttributeName(\u0026#34;panel-type\u0026#34;)] public HtmlPanelType PanelType { get; set; } public override void Process(TagHelperContext context, TagHelperOutput output) { //\u0026lt;div class=\u0026#34;panel panel-default\u0026#34;\u0026gt;  // \u0026lt;div class=\u0026#34;panel-heading\u0026#34;\u0026gt;  // \u0026lt;h3 class=\u0026#34;panel-title\u0026#34;\u0026gt;Panel title\u0026lt;/h3\u0026gt;  // \u0026lt;/div\u0026gt;  // \u0026lt;div class=\u0026#34;panel-body\u0026#34;\u0026gt;  // Panel content  // \u0026lt;/div\u0026gt;  //\u0026lt;/div\u0026gt;  // header content  var panelHeadingContent = new TagBuilder(\u0026#34;h3\u0026#34;); panelHeadingContent.SetInnerText(Title); // header  var panelHeading = new TagBuilder(\u0026#34;div\u0026#34;); panelHeading.AddCssClass(\u0026#34;panel-heading\u0026#34;); panelHeading.InnerHtml = panelHeadingContent.ToHtmlString(TagRenderMode.Normal).ToString(); // body  var panelBody = new TagBuilder(\u0026#34;div\u0026#34;); panelBody.AddCssClass(\u0026#34;panel-body\u0026#34;); panelBody.InnerHtml = context.GetChildContentAsync().Result.GetContent(); // panel  var panel = new TagBuilder(\u0026#34;div\u0026#34;); panel.AddCssClass(\u0026#34;panel\u0026#34;); AddPanelTypeStyle(panel, PanelType); // replace the custom tag with the panel just built  output.MergeAttributes(panel); var content = panelHeading.ToHtmlString(TagRenderMode.Normal).ToString(); content += panelBody.ToHtmlString(TagRenderMode.Normal).ToString(); output.Content.SetContent(content); base.Process(context, output); } private void AddPanelTypeStyle(TagBuilder panel, HtmlPanelType type) { switch (type) { case HtmlPanelType.Default: panel.AddCssClass(\u0026#34;panel-default\u0026#34;); break; case HtmlPanelType.Primary: panel.AddCssClass(\u0026#34;panel-primary\u0026#34;); break; case HtmlPanelType.Info: panel.AddCssClass(\u0026#34;panel-info\u0026#34;); break; case HtmlPanelType.Success: panel.AddCssClass(\u0026#34;panel-success\u0026#34;); break; case HtmlPanelType.Warning: panel.AddCssClass(\u0026#34;panel-warning\u0026#34;); break; case HtmlPanelType.Danger: panel.AddCssClass(\u0026#34;panel-danger\u0026#34;); break; default: throw new InvalidOperationException(\u0026#34;The panel type specified is not specified or invalid\u0026#34;); } } } ASP.NET 5 is in beta at the time this post is published and the final version may be different than the beta version.\n\r"
},
{
	"uri": "https://kodebot.com/blog/2015/asp-net-5-environment-specific-pipeline-configuration/",
	"title": "ASP.NET 5 - Environment specific pipeline configuration",
	"tags": ["ASP.NET", "MVC"],
	"description": "",
	"content": "// Example  public class Startup { private readonly IHostingEnvironment _env; public Startup(IHostingEnvironment env) { _env = env; } public void ConfigureServices(IServiceCollection services) { if (_env.IsEnvironment(\u0026#34;Production\u0026#34;)) { // read prod config  } else { // read dev config  } } . . . } // Full example  public class Startup { private readonly IHostingEnvironment _env; public Startup(IHostingEnvironment env) { _env = env; } public void ConfigureServices(IServiceCollection services) { if (_env.IsEnvironment(\u0026#34;Production\u0026#34;)) { // read prod config  } else if (_env.IsEnvironment(\u0026#34;Staging\u0026#34;)) { // read staging config  } else { // read dev config  } } public void ConfigureDevelopment(IApplicationBuilder builder, IHostingEnvironment env) { // Development configuration  Configure(builder); } public void ConfigureStaging(IApplicationBuilder builder) { // Staging configuration  Configure(builder); } public void ConfigureProduction(IApplicationBuilder builder) { // Production configuration  Configure(builder); } public void Configure(IApplicationBuilder builder) { // Common  } } "
},
{
	"uri": "https://kodebot.com/blog/2015/owin-katana-core-middleware-patterns/",
	"title": "Owin - Katana core middleware patterns",
	"tags": ["ASP.NET", "MVC"],
	"description": "",
	"content": "// Delegate Pattern Func\u0026lt;AppFunc, AppFunc\u0026gt; where AppFunc is Func\u0026lt;IDictionary\u0026lt;string, object\u0026gt;, Task\u0026gt;\u0026gt;\n// Delegate Pattern Implementation public void Configuration(IAppBuilder builder) { builder.Use(new Func\u0026lt;AppFunc, AppFunc\u0026gt;(next =\u0026gt; async env =\u0026gt; { Console.WriteLine(\u0026#34;From Delegate Middleware - Start\u0026#34;); await next(env); Console.WriteLine(\u0026#34;From Delegate Middleware - End\u0026#34;); })); } // Delegate Pattern with additional parameters public void Configuration(IAppBuilder builder) { builder.Use(new Func\u0026lt;AppFunc, string, AppFunc\u0026gt;((next, param) =\u0026gt; async (env) =\u0026gt; { Console.WriteLine(\u0026#34;From Delegate Middleware with param- Start\u0026#34;); Console.WriteLine(\u0026#34;Paramater value : {0}\u0026#34;, param); await next(env); Console.WriteLine(\u0026#34;From Delegate Middleware with param- End\u0026#34;); }), \u0026#34;additional param\u0026#34;); } // Instance Pattern method signatures public void Initialize(AppFunc next, params object[] args); public Task Invoke(IDictionary\u0026lt;string, object\u0026gt; environment); // Instance Pattern with parameter public void Configuration(IAppBuilder builder) { builder.Use(new InstanceMiddlewareWithParam(), \u0026#34;instance param value\u0026#34;); } public class InstanceMiddlewareWithParam { private AppFunc _next; private string _param; public void Initialize(AppFunc next, string param) { _next = next; _param = param; } public async Task Invoke(IDictionary\u0026lt;string, object\u0026gt; environment) { Console.WriteLine(\u0026#34;From Instance Middleware with param - Start\u0026#34;); Console.WriteLine(\u0026#34;Parameter value: {0}\u0026#34;, _param); await _next(environment); Console.WriteLine(\u0026#34;From Instance Middleware with param - Start\u0026#34;); } } // Generator / Nested Delegate pattern public AppFunc Invoke(AppFunc next, params object[] args); // Middleware using Generator / Nested Delegate pattern  public void Configuration(IAppBuilder builder) { builder.Use(new GeneratorMiddlewareWithParam(), \u0026#34;generator param value\u0026#34;); } public class InstanceMiddlewareWithParam { private AppFunc _next; private string _param; public void Initialize(AppFunc next, string param) { _next = next; _param = param; } public async Task Invoke(IDictionary\u0026lt;string, object\u0026gt; environment) { Console.WriteLine(\u0026#34;From Instance Middleware with param - Start\u0026#34;); Console.WriteLine(\u0026#34;Parameter value: {0}\u0026#34;, _param); await _next(environment); Console.WriteLine(\u0026#34;From Instance Middleware with param - Start\u0026#34;); } } // Constructor Type / Type pattern public Ctor(AppFunc next, params object[] args); public Task Invoke(IDictionary\u0026lt;string, object\u0026gt; env); // Middleware using Constructor Type / Type pattern  public void Configuration(IAppBuilder builder) { builder.Use(typeof(ConstructorTypeMiddlewareWithParam), \u0026#34;type param value\u0026#34;); } public class ConstructorTypeMiddlewareWithParam { private readonly AppFunc _next; private readonly string _param; public ConstructorTypeMiddlewareWithParam(AppFunc next, string param) { _next = next; _param = param; } public async Task Invoke(IDictionary\u0026lt;string, object\u0026gt; env) { Console.WriteLine(\u0026#34;From Constructor Type Middleware - Start\u0026#34;); Console.WriteLine(\u0026#34;Parameter value: {0}\u0026#34;, _param); await _next(env); Console.WriteLine(\u0026#34;From Constructor Type Middleware - End\u0026#34;); } } "
},
{
	"uri": "https://kodebot.com/blog/2015/typescript-this-reference-in-angularjs-event-handler/",
	"title": "TypeScript - &#39;this&#39; reference in AngularJS event handler",
	"tags": ["TypeScript", "AngularJS"],
	"description": "",
	"content": "// Controller using class module App.Home { interface IHomeViewModel { title: string; } class HomeController implements IHomeViewModel { title: string = \u0026#34;Welcome!!!\u0026#34;; static $inject = [\u0026#34;$location\u0026#34;, \u0026#34;$rootScope\u0026#34;] constructor( private $location: ng.ILocationService, private $rootScope: ng.IRootScopeService) { } } angular.module(\u0026#34;app\u0026#34;) .controller(\u0026#34;homeController\u0026#34;, HomeController); } In this example, an interface called IHomeViewModel is created to represent the public members of the controller and a class HomeController is created which implements the interface.Dependencies are injected using static $inject member and injected dependencies are declared as private members.\nHere is an example of how we will add handler to Angular\u0026rsquo;s $routeChangeStart event which is raised when route change is initiated\n// Event handlers private hookEventHandlers():void { this.$rootScope.$on(\u0026#34;$routeChangeStart\u0026#34;, this.onRouteChangeStart); } private onRouteChangeStart():void { console.log(this.title); } The hookEventHandlers method is called from the constructor of the controller which adds handler to $routeChangeStart event and the handler simply logs title member of the class into console.\nWhen this method is run, you would expect it to show \u0026lsquo;Welcome!!!\u0026rsquo; in the console but it shows undefined instead.\nThis is happening because the caller of the method is NOT the instance of the class where it is defined, so this doesn\u0026rsquo;t have a member named title.\n// Event handler using arrow function private hookEventHandlers(): void { this.$rootScope.$on(\u0026#34;$routeChangeStart\u0026#34;,() =\u0026gt; { this.onRouteChangeStart.call(this); }); } private onRouteChangeStart(): void { console.log(this.title); } In this example, we have changed our event handler to be arrow function and the arrow function invokes onRouteChangeStart using call function and passing current instance of the class where it is defined as this reference.\nBut, how does arrow function has correct reference of this? When arrow function is created, this is lexically bound to the location where it is created. In this case, arrow function is created inside the member of a class where this represents the current instance of the class. So this reference inside the arrow function also represents the current instance of the class where it is created. That\u0026rsquo;s it :)\n// Full code example module App.Home { interface IHomeViewModel { title: string; } class HomeController implements IHomeViewModel { title: string = \u0026#34;Welcome!!!\u0026#34;; static $inject = [\u0026#34;$location\u0026#34;, \u0026#34;$rootScope\u0026#34;] constructor( private $location: ng.ILocationService, private $rootScope: ng.IRootScopeService) { this.hookEventHandlers(); } private hookEventHandlers(): void { this.$rootScope.$on(\u0026#34;$routeChangeStart\u0026#34;,() =\u0026gt;; { this.onRouteChangeStart.call(this); }); } private onRouteChangeStart(): void { console.log(this.title); } } angular.module(\u0026#34;app\u0026#34;) .controller(\u0026#34;homeController\u0026#34;, HomeController); } "
},
{
	"uri": "https://kodebot.com/blog/2015/typescript-build-automation-in-asp-net-5-mvc6-using-gulp/",
	"title": "TypeScript build automation in ASP.NET 5 (MVC6) using Gulp",
	"tags": ["ASP.NET", "MVC", "TypeScript"],
	"description": "",
	"content": "# creates package.json npm init # install packages npm install gulp gulp-typescript gulp-tslint gulp-tslint-stylish gulp-sourcemaps gulp-inject gulp-rimraf --save-dev // Package imports var gulp = require(\u0026#39;gulp\u0026#39;); var typescript = require(\u0026#39;gulp-typescript\u0026#39;); var tslint = require(\u0026#39;gulp-tslint\u0026#39;); var tslintStyle = require(\u0026#39;gulp-tslint-stylish\u0026#39;); var sourcemaps = require(\u0026#39;gulp-sourcemaps\u0026#39;); var inject = require(\u0026#39;gulp-inject\u0026#39;); var rimraf = require(\u0026#39;gulp-rimraf\u0026#39;); // clean gulp.task(\u0026#39;clean\u0026#39;, function () { gulp.src(\u0026#39;wwwroot/js/app\u0026#39;, { read: false }) .pipe(rimraf()) }); // TS Lint var tsLintConfig = require(\u0026#39;./tslintConfig\u0026#39;); gulp.task(\u0026#39;ts-lint\u0026#39;, function () { gulp.src(\u0026#39;wwwroot/**/*.ts\u0026#39;) .pipe(tslint(tsLintConfig)) .pipe(tslint.report(tslintStyle, { emitError: false, sort: true, bell: true })); }); // TS Compile gulp.task(\u0026#39;ts-compile\u0026#39;, [\u0026#39;ts-lint\u0026#39;, \u0026#39;clean\u0026#39;], function () { var tsResult = gulp.src(\u0026#39;wwwroot/**/*.ts\u0026#39;) .pipe(sourcemaps.init()) .pipe(typescript()); tsResult.js .pipe(sourcemaps.write(\u0026#39;.\u0026#39;)) .pipe(gulp.dest(\u0026#39;wwwroot/js\u0026#39;)); }); // Inject  gulp.task(\u0026#39;inject\u0026#39;, [\u0026#39;ts-compile\u0026#39;], function () { var target = gulp.src(\u0026#39;wwwroot/index.html\u0026#39;); var sources = gulp.src([\u0026#39;wwwroot/js/app/**/*.js\u0026#39;], { read: false }); target.pipe(inject(sources, { relative: true })) .pipe(gulp.dest(\u0026#39;wwwroot\u0026#39;)); }); \u0026lt;!--injection comment--\u0026gt; \u0026lt;!--inject:js--\u0026gt; \u0026lt;!--endinject--\u0026gt; // Watch gulp.task(\u0026#39;ts-watch\u0026#39;, function () { gulp.watch(\u0026#39;wwwroot/**/*.ts\u0026#39;, [\u0026#39;inject\u0026#39;]); }); // Default task gulp.task(\u0026#39;default\u0026#39;, [\u0026#39;inject\u0026#39;]); // ts-compile updated gulp.task(\u0026#39;ts-compile\u0026#39;, [\u0026#39;ts-lint\u0026#39;, \u0026#39;clean\u0026#39;], function () { var tsResult = gulp.src(\u0026#39;wwwroot/**/*.ts\u0026#39;) .pipe(sourcemaps.init()) .pipe(typescript()); tsResult.js .pipe(sourcemaps.write(\u0026#34;.\u0026#34;, { sourceRoot: \u0026#39;wwwroot/app\u0026#39; })) .pipe(gulp.dest(\u0026#39;wwwroot/js\u0026#39;)); }); "
},
{
	"uri": "https://kodebot.com/blog/2015/mvc-6-camel-case-json/",
	"title": "MVC 6 Camel Case JSON",
	"tags": ["ASP.NET", "MVC"],
	"description": "",
	"content": "This means, if you have an application which uses both MVC controllers and Web API controllers then you need to apply any custom JSON serialization configurations twice or you should replace JavaScriptSerializer with JSON.NET.\n// Sample  public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddMvc() .Configure\u0026lt;MvcOptions\u0026gt;(options =\u0026gt; { var jsonOutputFormatter = new JsonOutputFormatter(); jsonOutputFormatter.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); options.OutputFormatters.Insert(0, jsonOutputFormatter); }); } public void Configure(IApplicationBuilder app) { app.UseMvc(); } } "
},
{
	"uri": "https://kodebot.com/blog/2015/tpl-task-and-windows-identity-impersonation-the-beauty-of-closure/",
	"title": "TPL Task and Windows Identity Impersonation - The beauty of Closure",
	"tags": ["C#"],
	"description": "",
	"content": "// naive task code  Task.Run(() =\u0026gt; { // Task code here }); To make this work, I need to invoke the method in the task under impersonated context. The easiest way is to capture the WindowsIdentity and make it available to the task function so it can execute any code under the impersonated context.\n// Task using closure var currentWindowsIdentity = WindowsIdentity.GetCurrent(); Task.Run(() =\u0026gt; { using (currentWindowsIdentity.Impersonate()) { // Task code here  } }); "
},
{
	"uri": "https://kodebot.com/tags/e2e-testing/",
	"title": "e2e-testing",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/selenium-and-page-objects/",
	"title": "Selenium and Page Objects",
	"tags": ["C#", "e2e-testing"],
	"description": "",
	"content": "// Search Page \tpublic class BingSearch { private IWebElement _searchTerm; private List\u0026lt;BingSearchResult\u0026gt; _searchResults; public BingSearch() { Browser.GoTo(\u0026#34;http://www.bing.com\u0026#34;); } public string SearchTerm { get { return _searchTerm.Text; } set { _searchTerm = _searchTerm ?? Browser.WebDriver.FindElement(By.Name(\u0026#34;q\u0026#34;)); _searchTerm.SendKeys(value); } } public void Search() { if (_searchTerm != null) { if (_searchResults != null) { _searchResults.Clear(); } _searchTerm.Submit(); } } public List\u0026lt;BingSearchResult\u0026gt; SearchResults { get { _searchResults = _searchResults ?? new List\u0026lt;BingSearchResult\u0026gt;(); if (!_searchResults.Any()) { var elements = Browser.WebDriver.FindElements(By.CssSelector(\u0026#34;.b_algo a\u0026#34;)); foreach (var element in elements) { _searchResults.Add(new BingSearchResult() { DisplayText = element.Text, Link = element.GetAttribute(\u0026#34;href\u0026#34;) }); } } return _searchResults; } } } // Search Result  public class BingSearchResult { public string DisplayText { get; set; } public string Link { get; set; } } // Browser abstraction \tpublic static class Browser { private static IWebDriver _driver; static Browser() { _driver = new FirefoxDriver(); _driver.Manage().Timeouts().ImplicitlyWait(TimeSpan.FromSeconds(10)); } public static void GoTo(string url) { _driver.Navigate().GoToUrl(url); } public static IWebDriver WebDriver { get { return _driver; } } public static void Close() { _driver.Close(); } } If you look at the BingSearch class it doesn\u0026rsquo;t expose any Selenium objects but it has a list for SearchResults which uses BingSearchResult as its generic type. The BingSearchResult represents only one result in the page. Because I don\u0026rsquo;t want to page through the search result I didn\u0026rsquo;t bother creating any type to support it.\nBrowser is represented using static class in this sample but it doesn\u0026rsquo;t have to be static class.\n"
},
{
	"uri": "https://kodebot.com/blog/2015/ecmascript-6-sublime-text-editor-build-system/",
	"title": "ECMAScript 6 - Sublime Text editor build system",
	"tags": ["JavaScript", "tools"],
	"description": "",
	"content": "// gulpfile.js var gulp = require(\u0026#39;gulp\u0026#39;); var babel = require(\u0026#39;gulp-babel\u0026#39;); var shell = require(\u0026#39;gulp-shell\u0026#39;); gulp.task(\u0026#39;run\u0026#39;, function(){ return gulp.src(\u0026#39;app.js\u0026#39;) .pipe(babel()) .pipe(gulp.dest(\u0026#39;result\u0026#39;)) .pipe(shell([\u0026#39;node result\\\\app.js\u0026#39;])); }); { \u0026#34;cmd\u0026#34;: [\u0026#34;gulp.cmd\u0026#34;, \u0026#34;run\u0026#34;] } This setup is only recommended if you just want to play with ES6 like me. The grunt task uses hard coded files names and you need to use the same file name to get it working.\n\r"
},
{
	"uri": "https://kodebot.com/tags/tools/",
	"title": "tools",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/six-stars-of-angularjs-part-3/",
	"title": "Six stars of AngularJS - Part 3",
	"tags": ["JavaScript", "AngularJS"],
	"description": "",
	"content": "// sample 1 app.factory(\u0026#39;movieService\u0026#39;, movieService); function movieService() { return { getAllMovies: getAllMovies } function getAllMovies() { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } // sample 2  app.config(function($provide) { $provide.decorator(\u0026#39;movieService\u0026#39;, movieServiceDecorator); function movieServiceDecorator($delegate) { var originalGetAllMovies = $delegate.getAllMovies; $delegate.getAllMovies = function() { var result = originalGetAllMovies(); return result.slice(0,2); } return $delegate; } }); "
},
{
	"uri": "https://kodebot.com/blog/2015/six-stars-of-angularjs-part-2/",
	"title": "Six stars of AngularJS - Part 2",
	"tags": ["JavaScript", "AngularJS"],
	"description": "",
	"content": "// sample 1 $provide.factory(\u0026#39;movieService\u0026#39;, movieService); function movieService() { return { // service  getAllMovies: getAllMovies }; function getAllMovies() { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } // sample 2 var app = angular.module(\u0026#39;app\u0026#39;); app.factory(\u0026#39;movieService\u0026#39;, movieService); function movieService() { return { // service  getAllMovies: getAllMovies }; function getAllMovies() { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } // sample 3  app.service(\u0026#39;movieService\u0026#39;, movieService); function movieService() { this.getAllMovies = getAllMovies; function getAllMovies() { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } // sample 4  app.value(\u0026#39;movieService\u0026#39;, movieService()); // Note : function is invoked  function movieService() { return { getAllMovies: getAllMovies } function getAllMovies() { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } // sample 5  app.value(\u0026#39;movieService\u0026#39;, { getAllMovies: getAllMovies}); // sample 6  app.value(\u0026#39;movieService\u0026#39;, \u0026#34;sample service\u0026#34;); // sample 7 app.constant(\u0026#39;PI\u0026#39;, 3.14); "
},
{
	"uri": "https://kodebot.com/blog/2015/six-stars-of-angularjs-part-1/",
	"title": "Six stars of AngularJS - Part 1",
	"tags": ["JavaScript", "AngularJS"],
	"description": "",
	"content": "// provider sample 1  $provide.provider(\u0026#39;movieService\u0026#39;, movieServiceProvider); // provider  function movieServiceProvider() { var self = this; this.$get = movieService; // factory  this.isFrench = false; function movieService() { return { // service  getAllMovies: getAllMovies }; function getAllMovies() { if (self.isFrench) { return [\u0026#39;frenchMovie1\u0026#39;, \u0026#39;frenchMovie2\u0026#39;, \u0026#39;frenchMovie3\u0026#39;]; } else { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } } } // provider sample 2  var app = angular.module(\u0026#39;app\u0026#39;, []); app.config(function($provide) { // creates and register\u0026#39;s provider  var movieServiceProviderInstance = $provide.provider(\u0026#39;movieService\u0026#39;, movieServiceProvider); // configures provider  movieServiceProviderInstance.isFrench = true; function movieServiceProvider() { var self = this; this.$get = movieService; this.isFrench = false; function movieService() { return { getAllMovies: getAllMovies }; function getAllMovies() { if (self.isFrench) { return [\u0026#39;frenchMovie1\u0026#39;, \u0026#39;frenchMovie2\u0026#39;, \u0026#39;frenchMovie3\u0026#39;]; } else { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } } } }); // Sample 3  var app = angular.module(\u0026#39;app\u0026#39;); app.provider(\u0026#39;movieService\u0026#39;, movieServiceProvider); function movieServiceProvider() { var self = this; this.$get = movieService; this.isFrench = false; function movieService() { return { getAllMovies: getAllMovies }; function getAllMovies() { if (self.isFrench) { return [\u0026#39;frenchMovie1\u0026#39;, \u0026#39;frenchMovie2\u0026#39;, \u0026#39;frenchMovie3\u0026#39;]; } else { return [\u0026#39;engMovie1\u0026#39;, \u0026#39;engMovie2\u0026#39;, \u0026#39;engMovie3\u0026#39;]; } } } } "
},
{
	"uri": "https://kodebot.com/blog/2015/nsequencecomparer-to-compare-two-sequences/",
	"title": "NSequenceComparer to compare two sequences",
	"tags": ["Nuget", "C#"],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/tags/nuget/",
	"title": "Nuget",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/mocking-function-that-returns-promise/",
	"title": "Mocking function that returns promise",
	"tags": ["Unit Testing", "JavaScript", "AngularJS"],
	"description": "",
	"content": "// homeController (function () { \u0026#39;use strict\u0026#39;; angular .module(\u0026#39;app\u0026#39;) .controller(\u0026#39;homeController\u0026#39;, [\u0026#39;restaurantService\u0026#39;, homeController]); function homeController(restaurantService) { // #region viewmodel  var vm = this; vm.restaurants = []; // #endregion  // #region activate  activate(); function activate() { getRestaurants(); } // #endregion  // #region internal methods  function getRestaurants() { restaurantService.getRestaurants() .then(function (data) { vm.restaurants = data; }) .catch(function (error) { // error  }); } // #endregion  } })(); // unit test describe(\u0026#39;home page\u0026#39;, function () { var $controller; var $q; var restaurantService; beforeEach(function () { // load module  module(\u0026#39;app\u0026#39;); // overrides for mock injections  module(function ($provide) { // override any dependency here  // $provide.value(\u0026#39;service\u0026#39;, \u0026#39;override\u0026#39;);  }); // initialise  inject(function (_$controller_, _$q_, _restaurantService_) { $controller = _$controller_; $q = _$q_; restaurantService = _restaurantService_; }); }); describe(\u0026#39;when home controller is initiated\u0026#39;, function () { it(\u0026#39;should load restaurants\u0026#39;, function () { restaurantService.getRestaurants = function() { return $q.when([\u0026#39;rest1\u0026#39;, \u0026#39;rest2\u0026#39;]); } var target = $controller(\u0026#39;homeController\u0026#39;, { restaurantService: restaurantService }); expect(target.restaurants).toEqual([\u0026#39;rest1\u0026#39;, \u0026#39;rest2\u0026#39;]); }); }); }); // unit test describe(\u0026#39;home page\u0026#39;, function () { var $controller; var $q; var $rootScope; var restaurantService; beforeEach(function () { // load module  module(\u0026#39;app\u0026#39;); // overrides for mock injections  module(function ($provide) { // override any dependency here  // $provide.value(\u0026#39;service\u0026#39;, \u0026#39;override\u0026#39;);  }); // initialise  inject(function (_$controller_, _$q_, _$rootScope_, _restaurantService_) { $controller = _$controller_; $q = _$q_; $rootScope = _$rootScope_; restaurantService = _restaurantService_; }); }); describe(\u0026#39;when home controller is initiated\u0026#39;, function () { it(\u0026#39;should load restaurants\u0026#39;, function () { restaurantService.getRestaurants = function() { return $q.when([\u0026#39;rest1\u0026#39;, \u0026#39;rest2\u0026#39;]); } var target = $controller(\u0026#39;homeController\u0026#39;, { restaurantService: restaurantService }); $rootScope.$digest(); expect(target.restaurants).toEqual([\u0026#39;rest1\u0026#39;, \u0026#39;rest2\u0026#39;]); }); }); }); "
},
{
	"uri": "https://kodebot.com/blog/2015/structuring-unit-tests/",
	"title": "Strucuring unit tests",
	"tags": ["Unit Testing", "C#"],
	"description": "",
	"content": "public class AddressValidator { public bool IsValid(IList\u0026lt;string\u0026gt; addressLines) { if (addressLines == null) { throw new ArgumentNullException(\u0026#34;addressLines\u0026#34;, \u0026#34;AddressLines cannot be null\u0026#34;); } if (addressLines.ElementAtOrDefault(0) != null \u0026amp;\u0026amp; addressLines.ElementAtOrDefault(4) != null) { return true; } if (addressLines.ElementAtOrDefault(0) != null \u0026amp;\u0026amp; addressLines.ElementAtOrDefault(1) != null \u0026amp;\u0026amp; addressLines.ElementAtOrDefault(2) != null) { return true; } return false; } public bool IsNonUkAddress(IEnumerable\u0026lt;string\u0026gt; addressLines) { // return true for UK address  return false; } } [TestClass] public class AddressVaidatorTests { private AddressValidator _target; [TestInitialize] public virtual void TestSetup() { _target = new AddressValidator(); // other test setups that are common for all the tests in this file.  } [TestClass] public class TheIsValidMethod : AddressVaidatorTests { [TestInitialize] public override void TestSetup() { base.TestSetup(); // additional test setups applicable for the current method under test  } [TestClass] public class WhenTheAddressIsNull : TheIsValidMethod { // add test initialiser here to setup anything that are  // applicable for the current scenario [TestMethod] [ExpectedException(typeof(ArgumentNullException))] public void ShouldThrowArgumentNullException() { // arrange  List\u0026lt;string\u0026gt; inputAddress = null; // act  _target.IsValid(inputAddress); // assert  // expected exception - ArgumentNullException.  } // add test cleanups here  } [TestClass] public class WhenAddressLine1AndPostcodeArePresent : TheIsValidMethod { // add test initialiser here to setup anything that are  // applicable for the current scenario [TestMethod] public void ShouldReturnTrue() { // arrange  var inputAddress = new List\u0026lt;string\u0026gt;() { \u0026#34;Address1\u0026#34;, null, null, null, \u0026#34;Postcode\u0026#34; }; // act  var actual = _target.IsValid(inputAddress); // assert  Assert.IsTrue(actual); } // add test cleanups here  } // add test cleanups here  } [TestClass] public class TheIsUkAddressMethod : AddressValidator { // tests  } [TestCleanup] public virtual void TestCleanup() { // any cleanups  } } "
},
{
	"uri": "https://kodebot.com/blog/2015/decorator-over-inheritance-hierarchy/",
	"title": "Decorator over Inheritance hierarchy",
	"tags": ["Design Pattern", "C#"],
	"description": "",
	"content": "public class Command : ICommand { public bool CanExecute(object parameter) { // normal can execute version  return true; } public event EventHandler CanExecuteChanged; public void Execute(object parameter) { // normal execute version  } } public class AuditedCommand:Command { public bool CanExecute(object parameter) { // audited can execute version  return base.CanExecute(parameter); } public void Execute(object parameter) { // audited execute version  base.Execute(parameter); } } public class SecureCommand : Command { public bool CanExecute(object parameter) { // Secure can execute version  return base.CanExecute(parameter); } public void Execute(object parameter) { // Secure execute version  base.Execute(parameter); } } public class Command : ICommand { public bool CanExecute(object parameter) { // normal can execute  return true; } public event EventHandler CanExecuteChanged; public void Execute(object parameter) { // normal execute  } } public abstract class CommandDecorator : ICommand { private ICommand _command; public CommandDecorator(ICommand command) { this._command = command; } public virtual bool CanExecute(object parameter) { return _command.CanExecute(parameter); } // should be a wrapper to the property in the base class  public event EventHandler CanExecuteChanged; public virtual void Execute(object parameter) { _command.Execute(parameter); } } public class AuditedCommand:CommandDecorator { public AuditedCommand(ICommand command):base(command) { } public override bool CanExecute(object parameter) { // Audit behaviour goes here  return base.CanExecute(parameter); } public override void Execute(object parameter) { // Audit behaviour goes here  base.Execute(parameter); } } public class SecureCommand : CommandDecorator { public SecureCommand(ICommand command):base(command) { } public override bool CanExecute(object parameter) { // Secure behaviour goes here  return base.CanExecute(parameter); } public override void Execute(object parameter) { // Secure behaviour goes here  base.Execute(parameter); } } // Here is how you compose your commands  ICommand auditedDecorator = new AuditedCommand(command); ICommand secureDecorator = new SecureCommand(command); ICommand auditedSecureDecorator = new SecureCommand(auditedDecorator); "
},
{
	"uri": "https://kodebot.com/tags/design-pattern/",
	"title": "Design Pattern",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/blog/2015/organize-angularjs-tests-within-a-spec/",
	"title": "Organize AngularJS Tests within a test file",
	"tags": ["Unit Testing", "JavaScript", "AngularJS"],
	"description": "",
	"content": "var $controller; var calculatorService; beforeEach(function () { // load module  module(\u0026#39;app\u0026#39;); // overrides for mock injections  module(function ($provide) { // override any dependency here  // $provide.value(\u0026#39;service\u0026#39;, \u0026#39;override\u0026#39;);  }); // initialise  inject(function(_$controller_, _calculatorService_) { $controller = _$controller_; calculatorService = _calculatorService_; }); }); it(\u0026#39;should initialise the controller successfully\u0026#39;, function() { // act  var result = $controller(\u0026#39;homeController\u0026#39;); // assert  expect(result).toBeDefined(); }); describe(\u0026#39;when add is performed\u0026#39;, function() { it(\u0026#39;should invoke add in calculatorService\u0026#39;, function() { // arrange  // replace original method with spy  calculatorService.add = jasmine.createSpy(\u0026#39;add\u0026#39;); var target = $controller(\u0026#39;homeController\u0026#39;, { calculatorService: calculatorService }); // act  target.add(1, 2); // assert  expect(calculatorService.add).toHaveBeenCalledWith(1, 2); }); calculatorService.add = jasmine.createSpy(\u0026#39;add\u0026#39;); var target = $controller(\u0026#39;homeController\u0026#39;, { calculatorService: calculatorService }); // overrides for mock injections  module(function ($provide) { $provide.value(\u0026#39;claculatorService\u0026#39;, \u0026#39;mockCalculatorService\u0026#39;); }); "
},
{
	"uri": "https://kodebot.com/blog/2015/setup-chutzpah-to-run-javascript-tests-in-visualstudio/",
	"title": "Setup Chutzpah to Run Javascript Tests in VisualStudio",
	"tags": ["Unit Testing", "JavaScript", "Visual Studio"],
	"description": "",
	"content": " testing library/framework files code under test file(s) any additional files required to run code under test  /// \u0026lt;reference path=\u0026#34;../../../myapplication.web/scripts/jquery-1.10.2.min.js\u0026#34; /\u0026gt;  /// \u0026lt;reference path=\u0026#34;../../../myapplication.web/app/app.js\u0026#34; /\u0026gt; /// \u0026lt;reference path=\u0026#34;../../../myapplication.web/app/home/homecontroller.js\u0026#34; /\u0026gt;  describe(\u0026#39;home page\u0026#39;, function() { it(\u0026#39;should return tile as Home\u0026#39;, function() { expect(\u0026#39;home\u0026#39;).toBe(\u0026#39;home\u0026#39;); }); "
},
{
	"uri": "https://kodebot.com/tags/visual-studio/",
	"title": "Visual Studio",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kodebot.com/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "Hello fellow developer 👋 Thank you for visiting this page.\nThere is nothing special about me to highlight here. I am a software developer just like you. I am developing software professionally for about 16 years now.\nI live in Leeds, UK and work for companies that are commutable from Leeds.\nMost of the posts I write here are simply a knowledge dump for future me. I write posts here in one of the following styles based on my experience from my day job or side projects\n What is it? How do I do it? How do I fix it?  Hopefully you find it useful.\nContact If you want to contact me for any reason, just send me an email to info@kodebot.com. I will get back to you as soon as possible.\n"
},
{
	"uri": "https://kodebot.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
}]